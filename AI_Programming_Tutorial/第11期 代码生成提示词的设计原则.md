# 第11期 代码生成提示词的设计原则

欢迎回到AI编程深度专研系列教程！在上一期中，我们深入学习了提示词实验与效果评估，了解了如何通过科学实验和系统化管理来优化提示词效果。本期我们将进入教程的第四章：AI驱动的代码生成，首先探讨代码生成提示词的设计原则，这是获取高质量代码输出的基础。

## 4.1.1 精确性与明确性

### 4.1.1.1 清晰的任务定义

清晰的任务定义是生成高质量代码的第一步。明确的任务描述可以帮助AI准确理解您的需求，减少歧义，提高生成代码的相关性和正确性。

**任务定义的关键要素：**
1. **目标明确**：
   - 清楚说明要解决的问题或实现的功能
   - 避免模糊和抽象的描述
   - 使用具体、明确的语言

2. **范围界定**：
   - 明确任务的边界和限制
   - 指出需要包含和排除的内容
   - 设定合理的预期

3. **上下文提供**：
   - 提供必要的背景信息
   - 说明相关的技术环境和约束
   - 描述使用场景和要求

**任务定义示例对比：**

```
# 模糊的任务定义
帮我写个排序算法。

# 清晰的任务定义
实现一个高效的快速排序算法，用于对整数数组进行排序。算法应该是原地排序（不创建新数组），并能处理包含重复元素的数组。请使用Python语言，并添加详细的注释说明算法步骤。
```

### 4.1.1.2 精确的技术规范

精确的技术规范可以确保生成的代码符合特定的技术要求和标准，减少后续修改的需要。

**技术规范的主要内容：**
1. **语言与版本**：
   - 明确指定编程语言
   - 说明所需的语言版本
   - 提及相关的编译器或解释器

2. **框架与库**：
   - 指定要使用的框架或库
   - 说明版本要求
   - 提及任何必要的依赖项

3. **接口规范**：
   - 定义函数签名和参数
   - 说明返回值类型和格式
   - 指定输入输出示例

4. **编码标准**：
   - 提及要遵循的编码风格
   - 说明命名约定
   - 规定注释和文档要求

**技术规范示例：**

```
# 技术规范
- 语言：JavaScript (ES6+)
- 框架：React 18
- 函数签名：function useLocalStorage(key: string, initialValue: any): [any, (value: any) => void]
- 要求：
  1. 创建一个自定义Hook，用于在localStorage中存储和读取值
  2. 支持自动序列化和反序列化JSON数据
  3. 包含错误处理和边界情况检查
  4. 遵循React Hooks的最佳实践
  5. 添加TypeScript类型定义
```

### 4.1.1.3 明确的边界条件

明确指出边界条件和特殊情况可以确保生成的代码更加健壮，能够处理各种可能的输入和场景。

**常见的边界条件类型：**
1. **输入边界**：
   - 空输入（空数组、空字符串等）
   - 零值或负值
   - 极大或极小值
   - 特殊字符或格式

2. **逻辑边界**：
   - 循环终止条件
   - 递归基础情况
   - 条件分支的覆盖
   - 状态转换的处理

3. **错误情况**：
   - 异常输入处理
   - 资源访问失败
   - 权限不足情况
   - 并发或同步问题

4. **性能边界**：
   - 大数据量处理
   - 高频调用场景
   - 内存使用限制
   - 响应时间要求

**边界条件说明示例：**

```
# 边界条件说明
在实现这个文件读取函数时，请特别注意以下边界条件：

1. 输入验证：
   - 文件路径为空或null时返回适当错误
   - 路径不存在的文件处理
   - 权限不足情况的错误处理

2. 文件类型处理：
   - 处理超大文件（>1GB）时的内存使用
   - 二进制文件与文本文件的不同处理
   - 编码问题（如UTF-8与其他编码）

3. 性能考虑：
   - 针对频繁读取的小文件考虑缓存
   - 大文件应使用流式读取而非一次性加载
   - 提供异步接口以避免阻塞

4. 错误恢复：
   - 处理读取过程中的中断
   - 提供部分内容读取的选项
```

### 4.1.1.4 具体的输出要求

明确具体的输出要求可以帮助AI生成符合预期格式和风格的代码，减少后续调整的需要。

**输出要求的主要方面：**
1. **代码格式**：
   - 缩进风格和大小
   - 空行和代码块的组织
   - 行长度限制
   - 括号和引号的使用

2. **注释与文档**：
   - 注释的详细程度
   - 文档字符串的格式
   - API文档的要求
   - 示例代码的提供

3. **结构组织**：
   - 代码模块化程度
   - 函数和类的组织
   - 文件结构建议
   - 导入和依赖管理

4. **测试要求**：
   - 是否需要单元测试
   - 测试用例的覆盖范围
   - 测试框架的选择
   - 测试数据的提供

**输出要求示例：**

```
# 输出要求
请按照以下要求生成代码：

1. 代码格式：
   - 使用4个空格进行缩进
   - 行长度不超过80个字符
   - 类名使用驼峰命名法（PascalCase）
   - 函数和变量使用小驼峰命名法（camelCase）
   - 常量使用全大写加下划线（UPPER_SNAKE_CASE）

2. 注释要求：
   - 每个类和函数都必须有完整的文档字符串
   - 文档字符串使用Google风格
   - 复杂逻辑必须有内联注释
   - 解释非显而易见的设计决策

3. 结构组织：
   - 将相关功能组织到类中
   - 使用适当的继承和组合
   - 最小化类和函数的职责
   - 避免全局变量和副作用

4. 测试要求：
   - 为每个公共方法提供单元测试
   - 使用JUnit测试框架
   - 测试正常、边界和错误情况
   - 测试覆盖率不低于80%
```

## 4.1.2 上下文与相关性

### 4.1.2.1 相关背景信息的提供

提供相关的背景信息可以帮助AI更好地理解代码的使用场景和目的，生成更符合需求的解决方案。

**有效背景信息的类型：**
1. **项目背景**：
   - 项目的整体目标和范围
   - 相关的业务领域知识
   - 项目的架构和技术栈

2. **功能上下文**：
   - 该功能在系统中的作用
   - 与其他模块的交互关系
   - 数据流和处理流程

3. **约束条件**：
   - 硬件或性能限制
   - 安全性要求
   - 兼容性和可移植性需求

4. **设计决策**：
   - 已有的设计选择
   - 排除的其他方案及原因
   - 未来扩展的考虑

**背景信息提供示例：**

```
# 背景信息
我正在开发一个实时协作的文档编辑系统，类似于Google Docs。该系统的技术栈包括：

- 前端：React + TypeScript + Socket.io
- 后端：Node.js + Express + MongoDB
- 实时同步：Operational Transformation算法

当前需要实现的功能是文档版本历史记录系统，允许用户查看和恢复到文档的 previous versions。

系统约束：
- 每个文档可能有大量的版本历史（1000+版本）
- 需要支持版本比较和差异显示
- 存储空间有限，需要考虑版本存储的效率
- 需要支持版本标签和评论

已有的相关组件：
- DocumentService：管理文档的CRUD操作
- OperationService：处理文档操作的应用和转换
- UserService：管理用户认证和权限
```

### 4.1.2.2 相关代码和接口的引用

引用相关的代码和接口可以为AI提供更具体的上下文，确保生成的代码与现有系统无缝集成。

**代码引用的有效方式：**
1. **关键代码片段**：
   - 引用相关的类、函数或接口定义
   - 提供使用示例
   - 指出需要修改或扩展的部分

2. **接口和类型定义**：
   - 提供相关的接口定义
   - 说明数据模型和结构
   - 引用相关的类型和枚举

3. **依赖关系**：
   - 说明相关的外部依赖
   - 引用第三方库的API文档
   - 指出版本兼容性要求

4. **上下文整合**：
   - 说明新代码如何与现有代码交互
   - 提供调用链和数据流
   - 描述期望的集成方式

**代码引用示例：**

```
# 相关代码引用
请参考以下代码和接口，实现用户认证中间件：

## 1. 已有的用户模型
```javascript
// models/User.js
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // 已加密存储
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('User', UserSchema);
```

## 2. 已有的JWT工具函数
```javascript
// utils/jwt.js
const jwt = require('jsonwebtoken');

const generateToken = (userId, role) => {
  return jwt.sign({ id: userId, role }, process.env.JWT_SECRET, {
    expiresIn: '24h'
  });
};

const verifyToken = (token) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (err) {
    return null;
  }
};

module.exports = { generateToken, verifyToken };
```

## 3. 预期的中间件接口
```javascript
// middleware/auth.js
// 实现 authenticate 和 authorize 中间件函数
// authenticate 用于验证用户是否已登录
// authorize 用于验证用户是否有特定角色权限

module.exports = {
  authenticate,
  authorize
};
```
```

### 4.1.2.3 上下文相关性的维持

维持上下文相关性是确保生成代码与整体需求一致的重要因素。有效的上下文管理可以帮助AI保持专注并生成连贯的解决方案。

**上下文相关性维持策略：**
1. **上下文一致性**：
   - 保持术语和命名的一致性
   - 确保前后描述不矛盾
   - 维护逻辑流程的连贯性

2. **上下文精简**：
   - 只包含直接相关的信息
   - 避免无关或冗余的细节
   - 保持上下文的聚焦

3. **上下文结构**：
   - 使用清晰的结构组织信息
   - 按照逻辑顺序呈现内容
   - 使用适当的标题和分隔符

4. **多轮上下文**：
   - 在多轮对话中引用先前的内容
   - 适时总结已完成的工作
   - 明确指出新的需求和变化

**上下文相关性示例：**

```
# 初始请求
请实现一个用户认证系统的登录功能，使用Node.js和Express。

# 后续请求（保持上下文）
基于之前的登录功能，请添加以下增强：
1. 实现双因素认证支持
2. 添加登录尝试次数限制，防止暴力破解
3. 记录详细的登录日志，包括IP地址和时间戳

请确保新功能与现有的登录功能无缝集成，并保持相同的错误处理风格。
```

### 4.1.2.4 上下文冗余的避免

避免上下文冗余可以提高提示词的效率和清晰度，帮助AI更快地理解核心需求，减少混淆。

**避免上下文冗余的方法：**
1. **信息优先级**：
   - 优先提供最重要的信息
   - 将详细信息放在次要位置
   - 使用层次结构组织内容

2. **冗余识别**：
   - 避免重复描述相同的要求
   - 检查是否有相互矛盾的信息
   - 去除与当前任务无关的背景

3. **精确表述**：
   - 使用简洁明了的语言
   - 避免模糊和冗长的描述
   - 选择最能表达意图的词语

4. **结构化简化**：
   - 使用列表和表格替代冗长文本
   - 采用视觉化的方式呈现信息
   - 利用代码示例代替文字描述

**冗余与精简对比：**

```
# 冗余版本
我需要一个函数，这个函数是用Python写的，用来计算两个数字的和。我想要这个函数接受两个参数，这两个参数都是整数类型的，然后这个函数需要返回这两个整数的总和。另外，这个函数应该处理一些边界情况，比如如果输入不是数字类型，应该抛出一个异常。还有，我希望这个函数有一个好的名字，并且有适当的注释来说明它的用途和参数。

# 精简版本
请实现一个Python函数，满足以下要求：
- 函数名：add_numbers
- 参数：num1 (int), num2 (int)
- 返回值：两个数字的和 (int)
- 要求：
  1. 处理非整数输入，抛出TypeError异常
  2. 添加适当的函数文档字符串
  3. 包含类型注解
```

## 4.1.3 示例与引导

### 4.1.3.1 有效的示例使用

使用有效的示例可以帮助AI更好地理解期望的输出格式和内容，特别是对于复杂或特殊的需求。

**有效示例的类型：**
1. **输入-输出示例**：
   - 展示典型的输入和预期输出
   - 包含多种不同的情况
   - 覆盖边界条件和特殊情况

2. **代码风格示例**：
   - 展示期望的代码风格
   - 说明命名约定和格式要求
   - 提供注释和文档的示例

3. **结构示例**：
   - 展示代码的整体结构
   - 说明模块和文件的组织方式
   - 提供依赖关系的示例

4. **错误示例**：
   - 展示不期望的实现方式
   - 说明常见的错误和陷阱
   - 强调应该避免的做法

**有效示例使用示例：**

```
# 输入-输出示例
请实现一个字符串反转函数，满足以下要求：

函数签名：def reverse_string(s: str) -> str

输入-输出示例：
- 示例1：reverse_string("hello") → "olleh"
- 示例2：reverse_string("") → ""
- 示例3：reverse_string("A man, a plan, a canal: Panama") → "amanaP :lanac a ,nalp a ,nam A"

特殊要求：
- 保持原始字符串的所有字符，包括空格和标点符号
- 不使用内置的字符串反转方法
- 添加适当的类型注解和文档字符串
```

### 4.1.3.2 少样本学习技术

少样本学习是一种强大的技术，通过提供少量高质量的示例，引导AI生成符合预期的代码。

**少样本学习策略：**
1. **示例质量**：
   - 选择代表性强的示例
   - 确保示例的准确性和清晰度
   - 示例应展示关键概念和模式

2. **示例数量**：
   - 通常2-5个示例效果最佳
   - 避免过多示例导致信息过载
   - 每个示例聚焦于不同的方面或场景

3. **示例结构**：
   - 使用一致的格式展示示例
   - 清晰标记输入和输出
   - 提供简要的说明或解释

4. **示例多样性**：
   - 包含不同复杂度的示例
   - 覆盖不同的输入类型和场景
   - 包括典型案例和边缘情况

**少样本学习示例：**

```
# 少样本学习示例：实现不同数据类型的格式化函数

请实现一个通用的格式化函数，根据输入数据类型返回格式化后的字符串。使用以下示例作为参考：

示例1：
输入：format_data(42)
输出："Number: 42"

示例2：
输入：format_data("hello")
输出："String: 'hello'"

示例3：
输入：format_data([1, 2, 3])
输出："Array: [1, 2, 3]"

示例4：
输入：format_data({"name": "John", "age": 30})
输出："Object: {name: 'John', age: 30}"

函数要求：
- 支持数字、字符串、数组、对象、布尔值和null类型
- 对于对象，只显示前3个属性，如果更多则省略
- 添加适当的类型检查和错误处理
- 遵循JavaScript ES6+最佳实践
```

### 4.1.3.3 反例的使用

提供反例可以明确指出不期望的实现方式，帮助AI避免常见的错误和陷阱。

**反例的有效使用：**
1. **错误模式识别**：
   - 展示常见的错误实现
   - 解释为什么这是不正确的
   - 说明潜在的问题和风险

2. **反例的目的**：
   - 明确边界和限制
   - 避免误解和歧义
   - 强调特定的设计决策

3. **反例的结构**：
   - 清晰标记这是反例
   - 提供简短的错误解释
   - 展示正确的替代方案

4. **反例的平衡**：
   - 与正面示例一起使用
   - 不过度使用反例
   - 确保反例确实是错误的实现

**反例使用示例：**

```
# 反例使用：实现安全的密码哈希函数

请实现一个安全的密码哈希函数，确保用户密码的安全存储。

## 反例（不要这样做）：
```python
def hash_password(password):
    # 不安全！不要使用简单的MD5哈希
    import hashlib
    return hashlib.md5(password.encode()).hexdigest()
```

反例问题：
- MD5是不安全的哈希算法，容易被暴力破解
- 没有使用盐值(salt)，容易受到彩虹表攻击
- 缺乏哈希迭代次数，破解速度快

## 正确实现要求：
- 使用现代安全哈希算法（如bcrypt、Argon2等）
- 为每个密码生成唯一的盐值
- 使用适当的哈希轮数增强安全性
- 提供验证密码的配套函数
```

### 4.1.3.4 渐进式示例引导

渐进式示例引导通过从简单到复杂的示例序列，逐步引导AI理解和生成更复杂的代码。

**渐进式示例策略：**
1. **从基础到高级**：
   - 从最简单的情况开始
   - 逐步增加复杂度和细节
   - 确保每个步骤都建立在前一步的基础上

2. **概念分解**：
   - 将复杂概念分解为简单部分
   - 为每个部分提供示例
   - 最后展示如何组合这些部分

3. **渐进式任务**：
   - 设计一系列相关的小任务
   - 每个任务构建在先前任务的基础上
   - 逐步接近最终目标

4. **引导思考过程**：
   - 展示问题解决的思考过程
   - 解释每个步骤的目的和原理
   - 引导AI按照特定的思路思考

**渐进式示例引导示例：**

```
# 渐进式示例：实现二分查找算法

请按照以下渐进式示例实现二分查找算法：

## 步骤1：基本概念理解
二分查找是一种在有序数组中查找特定元素的高效算法，时间复杂度为O(log n)。

基本思路：
- 比较目标值与数组中间元素
- 如果相等，则找到目标
- 如果目标值小于中间元素，则在左半部分继续查找
- 如果目标值大于中间元素，则在右半部分继续查找

## 步骤2：简单实现
```python
def binary_search_simple(arr, target):
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid  # 找到目标，返回索引
        elif arr[mid] < target:
            left = mid + 1  # 目标在右半部分
        else:
            right = mid - 1  # 目标在左半部分
    
    return -1  # 未找到目标
```

## 步骤3：添加边界检查和注释
```python
def binary_search_with_checks(arr, target):
    """
    在有序数组中使用二分查找算法查找目标值
    
    参数:
        arr: 已排序的数组
        target: 要查找的值
        
    返回:
        目标值的索引，如果未找到则返回-1
    """
    # 边界检查
    if not arr or target is None:
        return -1
    
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        # 防止整数溢出的中间值计算
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid  # 找到目标，返回索引
        elif arr[mid] < target:
            left = mid + 1  # 目标在右半部分
        else:
            right = mid - 1  # 目标在左半部分
    
    return -1  # 未找到目标
```

## 步骤4：高级实现 - 支持重复元素和自定义比较
请实现一个高级版本的二分查找，支持以下功能：
- 当存在重复元素时，返回第一个匹配的索引
- 添加自定义比较函数的支持
- 优化处理各种边界情况
- 添加完整的类型注解
```

## 4.1.4 结构与格式

### 4.1.4.1 提示词的结构化设计

结构化的提示词设计可以提高信息的清晰度和组织性，帮助AI更有效地理解和处理需求。

**结构化提示词的关键要素：**
1. **清晰的标题层级**：
   - 使用标题和副标题组织内容
   - 建立明确的层次结构
   - 突出重要的部分

2. **逻辑分区**：
   - 将相关内容分组在一起
   - 使用分隔符区分不同部分
   - 按照处理顺序排列内容

3. **列表和表格**：
   - 使用列表呈现多个相关项
   - 使用表格比较不同选项
   - 使用编号列表表示步骤或优先级

4. **视觉提示**：
   - 使用粗体或斜体强调重要信息
   - 使用引用块突出显示特殊说明
   - 使用代码块展示代码示例

**结构化提示词示例：**

```markdown
# 任务：实现用户管理系统的核心功能

## 1. 技术要求
- **语言**：Java 17
- **框架**：Spring Boot 3.0
- **数据库**：PostgreSQL
- **认证**：Spring Security + JWT

## 2. 核心功能需求

### 2.1 用户注册
- 支持邮箱和手机号注册
- 密码强度验证（至少8位，包含大小写字母、数字和特殊字符）
- 发送验证码进行邮箱/手机验证
- 防止重复注册

### 2.2 用户登录
- 支持邮箱/手机号+密码登录
- 支持记住登录状态
- 登录失败次数限制（5次后锁定30分钟）
- 记录登录日志（IP、设备、时间）

### 2.3 用户信息管理
- 查看和修改个人基本信息
- 修改密码
- 绑定/解绑邮箱和手机号
- 上传和更新头像

## 3. 代码实现要求

### 3.1 架构设计
- 遵循分层架构（控制层、服务层、数据访问层）
- 实现依赖注入
- 使用DTO模式进行数据传输
- 实现统一的响应格式

### 3.2 安全要求
- 密码使用BCrypt加密存储
- 敏感信息传输使用HTTPS
- 实现防SQL注入和XSS攻击
- 添加CSRF保护

### 3.3 代码质量
- 遵循Java编码规范
- 为所有公共方法添加Javadoc
- 单元测试覆盖率达到80%以上
- 使用日志记录关键操作

## 4. 交付内容
- 完整的源代码
- 数据库脚本
- API文档（使用Swagger）
- 单元测试和集成测试
- 简要的系统设计文档
```

### 4.1.4.2 代码块的有效使用

有效使用代码块可以提供清晰的代码示例和上下文，帮助AI理解代码结构和格式要求。

**代码块使用的最佳实践：**
1. **语言标记**：
   - 始终指定代码块的编程语言
   - 确保语法高亮正确
   - 保持语言的一致性

2. **代码完整性**：
   - 提供完整的代码片段
   - 包含必要的导入和声明
   - 确保代码片段可以独立理解

3. **代码注释**：
   - 在代码中添加解释性注释
   - 标记关键部分和复杂逻辑
   - 指出需要修改或关注的地方

4. **格式和缩进**：
   - 保持一致的缩进风格
   - 遵循语言的格式规范
   - 确保长代码的可读性

**代码块使用示例：**

```python
# 代码块使用示例：实现一个自定义的装饰器

# 请实现一个用于记录函数执行时间的装饰器，具体要求如下：

```python
import time
import functools
from typing import Any, Callable

def timing_decorator(func: Callable) -> Callable:
    """
    用于测量函数执行时间的装饰器
    
    参数:
        func: 要装饰的函数
        
    返回:
        装饰后的函数，会打印执行时间
    """
    @functools.wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        # 记录开始时间
        start_time = time.time()
        
        # 执行原函数
        result = func(*args, **kwargs)
        
        # 计算执行时间
        end_time = time.time()
        execution_time = end_time - start_time
        
        # 打印执行时间信息
        print(f"函数 {func.__name__} 执行时间: {execution_time:.4f} 秒")
        
        return result
    
    return wrapper
```

# 使用示例
```python
@timing_decorator
def calculate_fibonacci(n: int) -> int:
    """计算斐波那契数列的第n项"""
    if n <= 1:
        return n
    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)

# 测试
time_taken = calculate_fibonacci(30)
```

请根据上述示例，实现一个增强版的timing_decorator，增加以下功能：
1. 支持记录到日志文件而不仅是打印到控制台
2. 支持设置阈值，只记录执行时间超过阈值的函数
3. 增加函数参数和返回值的可选记录功能
4. 添加对异步函数的支持
```

### 4.1.4.3 分隔符与标记的使用

适当使用分隔符和标记可以提高提示词的可读性和结构清晰度，帮助AI更好地解析和理解内容。

**有效使用分隔符和标记：**
1. **内容分隔**：
   - 使用 --- 分隔不同的主要部分
   - 使用 === 标记重要的章节
   - 使用空行分隔相关但不同的内容

2. **强调标记**：
   - 使用 **粗体** 强调关键概念和要求
   - 使用 *斜体* 表示特殊说明或注释
   - 使用 `行内代码` 表示代码术语和变量名

3. **引用和说明**：
   - 使用 > 引用块表示重要说明
   - 使用 [!WARNING] 等标记提示特殊注意事项
   - 使用列表标记不同的点或选项

4. **代码与文本分离**：
   - 清晰区分普通文本和代码
   - 使用 ``` 代码块包围所有代码示例
   - 在代码块前后添加说明文本

**分隔符与标记使用示例：**

```markdown
# 任务：实现数据验证器

---

## 要求概述

**核心功能**：创建一个通用的数据验证库，支持不同类型的数据验证规则。

> **注意**：验证器应该是可扩展的，允许轻松添加新的验证规则。

---

## 技术规范

- **语言**：TypeScript 4.9+
- **环境**：Node.js 16+
- **测试框架**：Jest
- **打包工具**：Rollup

---

## 主要组件

### 1. `Validator` 类

这是库的核心类，提供主要的验证功能：

```typescript
class Validator {
  // 构造函数和方法定义
}
```

### 2. `ValidationRule` 接口

定义验证规则的标准接口：

```typescript
interface ValidationRule {
  // 接口定义
}
```

---

## 验证规则实现

实现以下基本验证规则：

1. **`RequiredRule`** - 确保值不为null或undefined
2. **`MinLengthRule`** - 字符串最小长度验证
3. **`MaxLengthRule`** - 字符串最大长度验证
4. **`PatternRule`** - 正则表达式匹配验证
5. **`RangeRule`** - 数值范围验证

---

## 使用示例

```typescript
// 示例用法
const validator = new Validator();

// 定义验证规则
validator.addRule('username', new RequiredRule());
validator.addRule('username', new MinLengthRule(3));
validator.addRule('username', new MaxLengthRule(20));

// 执行验证
const result = validator.validate({
  username: 'john'
});

console.log(result.valid); // 输出: true
```

> [!IMPORTANT]
> 请确保所有代码都包含适当的TypeScript类型定义，并添加完整的单元测试。
```

### 4.1.4.4 格式一致性的维持

维持格式一致性可以提高提示词的专业性和可读性，帮助AI更好地理解和处理需求。

**格式一致性的关键方面：**
1. **标题和层级**：
   - 使用一致的标题样式和层级
   - 保持标题的缩进和编号一致
   - 遵循相同的命名约定

2. **代码格式**：
   - 所有代码块使用相同的语言标记
   - 保持一致的缩进和空行风格
   - 遵循相同的代码注释风格

3. **列表和表格**：
   - 统一使用项目符号或编号列表
   - 表格格式保持一致
   - 列表项的缩进和格式统一

4. **术语和命名**：
   - 保持术语的一致性
   - 使用相同的命名约定
   - 避免使用同义词或不同的表达方式

**格式一致性示例：**

```markdown
# 格式一致性示例

## 1. 标题层级一致性

### 1.1 子部分
- 项目符号列表
- 保持一致的格式

### 1.2 另一个子部分
1. 编号列表
2. 保持顺序一致性

## 2. 代码块一致性

```javascript
// 始终指定语言
function example1() {
  console.log('代码格式一致');
}
```

```javascript
// 保持相同的缩进和风格
function example2() {
  console.log('保持格式统一');
}
```

## 3. 表格格式一致性

| 列1 | 列2 | 列3 |
|-----|-----|-----|
| 数据1 | 数据2 | 数据3 |
| 数据4 | 数据5 | 数据6 |

## 4. 术语一致性

- 始终使用"函数"而非"方法"(在JavaScript上下文中)
- 保持变量命名风格一致
- 避免在同一提示中混合使用同义词
```

## 总结

本期我们深入探讨了代码生成提示词的设计原则，包括精确性与明确性、上下文与相关性、示例与引导以及结构与格式四个核心方面。我们学习了如何通过清晰的任务定义、精确的技术规范、明确的边界条件和具体的输出要求来确保提示词的精确性；如何通过提供相关背景信息、引用相关代码和接口、维持上下文相关性以及避免上下文冗余来增强上下文的有效性；如何通过有效使用示例、应用少样本学习技术、使用反例以及渐进式示例引导来更好地引导AI；以及如何通过结构化设计、有效使用代码块、合理使用分隔符与标记以及维持格式一致性来提高提示词的清晰度和专业性。

掌握这些提示词设计原则将帮助您生成更有效的提示词，从而获得更高质量的代码输出。在下一期中，我们将继续探讨第四章的内容，深入学习"常见编程语言的提示技巧"，敬请期待！

## 思考与练习

1. 选择一个编程任务，分别使用模糊和精确的提示词来测试AI的输出差异。
2. 实践结构化提示词设计，为一个复杂任务创建组织良好的提示词。
3. 尝试使用少样本学习技术，通过2-3个示例引导AI生成符合特定要求的代码。
4. 分析您之前使用过的提示词，识别可以改进的地方，并应用本章节学习的原则进行优化。

---

*本教程将持续更新，跟进AI编程领域的最新发展与最佳实践。*