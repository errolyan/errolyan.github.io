# 第24期 构建个人AI编程系统：提示库与工作流定制

欢迎回到AI编程深度专研系列教程！在前几期的内容中，我们已经探索了AI在开发环境集成、版本控制、文档生成等方面的应用。本期我们将继续第六章的内容，聚焦于如何构建个人化的AI编程系统，包括提示库的建立与管理、针对特定领域的提示优化、多模型协同工作策略以及持续学习与能力提升路径。

## 6.4.1 个人提示库的建立与管理

在AI编程过程中，有效的提示词是产出高质量代码的关键。建立和管理个人提示库可以帮助您积累经验，提高工作效率。

### 提示库的设计与组织结构

一个良好的提示库应该有清晰的组织结构，便于查找和复用。以下是一个提示库的设计方案：

```python
#!/usr/bin/env python3
# prompt_library_manager.py - 提示词库管理工具

import os
import sys
import json
import yaml
import argparse
import re
import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional

class PromptLibraryManager:
    """
    提示词库管理器，用于管理和组织AI编程提示词
    """
    
    def __init__(self, library_path: str = None):
        """
        初始化提示词库管理器
        
        Args:
            library_path: 提示词库的存储路径
        """
        # 如果没有指定路径，使用默认路径
        if library_path is None:
            library_path = os.path.join(str(Path.home()), ".ai_prompt_library")
        
        self.library_path = library_path
        self.prompts = {}
        self.initialized = False
        
        # 确保库目录存在
        os.makedirs(library_path, exist_ok=True)
        self._load_prompts()
    
    def _load_prompts(self) -> None:
        """
        从文件系统加载提示词库
        """
        try:
            # 遍历库目录中的所有文件
            for root, _, files in os.walk(self.library_path):
                for file in files:
                    if file.endswith('.json') or file.endswith('.yaml') or file.endswith('.yml'):
                        file_path = os.path.join(root, file)
                        category = os.path.relpath(root, self.library_path)
                        
                        # 根目录下的文件归类为通用
                        if category == '.':
                            category = 'general'
                        
                        # 确保类别存在
                        if category not in self.prompts:
                            self.prompts[category] = {}
                        
                        try:
                            # 根据文件类型加载
                            if file.endswith('.json'):
                                with open(file_path, 'r', encoding='utf-8') as f:
                                    data = json.load(f)
                            else:
                                with open(file_path, 'r', encoding='utf-8') as f:
                                    data = yaml.safe_load(f)
                            
                            # 添加到提示词库
                            if isinstance(data, dict):
                                # 单个提示词文件
                                prompt_id = os.path.splitext(file)[0]
                                self.prompts[category][prompt_id] = {
                                    'content': data.get('prompt', ''),
                                    'description': data.get('description', ''),
                                    'tags': data.get('tags', []),
                                    'created_at': data.get('created_at', datetime.datetime.now().isoformat()),
                                    'updated_at': data.get('updated_at', datetime.datetime.now().isoformat()),
                                    'metadata': data.get('metadata', {})
                                }
                            elif isinstance(data, list):
                                # 多个提示词的集合文件
                                for item in data:
                                    if isinstance(item, dict) and 'id' in item:
                                        prompt_id = item['id']
                                        self.prompts[category][prompt_id] = {
                                            'content': item.get('prompt', ''),
                                            'description': item.get('description', ''),
                                            'tags': item.get('tags', []),
                                            'created_at': item.get('created_at', datetime.datetime.now().isoformat()),
                                            'updated_at': item.get('updated_at', datetime.datetime.now().isoformat()),
                                            'metadata': item.get('metadata', {})
                                        }
                        except Exception as e:
                            print(f"加载文件失败 {file_path}: {e}")
            
            self.initialized = True
        except Exception as e:
            print(f"加载提示词库失败: {e}")
    
    def add_prompt(self, prompt_id: str, content: str, description: str = '', 
                   tags: List[str] = None, category: str = 'general', 
                   metadata: Dict[str, Any] = None) -> bool:
        """
        添加新的提示词到库中
        
        Args:
            prompt_id: 提示词的唯一标识符
            content: 提示词内容
            description: 提示词描述
            tags: 标签列表
            category: 类别
            metadata: 额外的元数据
            
        Returns:
            是否添加成功
        """
        try:
            # 确保类别存在
            if category not in self.prompts:
                self.prompts[category] = {}
            
            # 添加提示词
            self.prompts[category][prompt_id] = {
                'content': content,
                'description': description,
                'tags': tags or [],
                'created_at': datetime.datetime.now().isoformat(),
                'updated_at': datetime.datetime.now().isoformat(),
                'metadata': metadata or {}
            }
            
            # 保存到文件
            self._save_prompt(category, prompt_id)
            return True
        except Exception as e:
            print(f"添加提示词失败: {e}")
            return False
    
    def update_prompt(self, prompt_id: str, content: Optional[str] = None, 
                     description: Optional[str] = None, tags: Optional[List[str]] = None,
                     metadata: Optional[Dict[str, Any]] = None, category: str = None) -> bool:
        """
        更新现有提示词
        
        Args:
            prompt_id: 提示词的唯一标识符
            content: 新的提示词内容（可选）
            description: 新的描述（可选）
            tags: 新的标签列表（可选）
            metadata: 新的元数据（可选）
            category: 提示词所在的类别，如果未指定则搜索所有类别
            
        Returns:
            是否更新成功
        """
        try:
            # 查找提示词
            target_category = None
            if category:
                if category in self.prompts and prompt_id in self.prompts[category]:
                    target_category = category
            else:
                # 搜索所有类别
                for cat, prompts in self.prompts.items():
                    if prompt_id in prompts:
                        target_category = cat
                        break
            
            if not target_category:
                print(f"未找到提示词: {prompt_id}")
                return False
            
            # 更新提示词
            if content is not None:
                self.prompts[target_category][prompt_id]['content'] = content
            if description is not None:
                self.prompts[target_category][prompt_id]['description'] = description
            if tags is not None:
                self.prompts[target_category][prompt_id]['tags'] = tags
            if metadata is not None:
                self.prompts[target_category][prompt_id]['metadata'] = metadata
            
            # 更新时间戳
            self.prompts[target_category][prompt_id]['updated_at'] = datetime.datetime.now().isoformat()
            
            # 保存到文件
            self._save_prompt(target_category, prompt_id)
            return True
        except Exception as e:
            print(f"更新提示词失败: {e}")
            return False
    
    def delete_prompt(self, prompt_id: str, category: str = None) -> bool:
        """
        删除提示词
        
        Args:
            prompt_id: 提示词的唯一标识符
            category: 提示词所在的类别，如果未指定则搜索所有类别
            
        Returns:
            是否删除成功
        """
        try:
            # 查找提示词
            target_category = None
            if category:
                if category in self.prompts and prompt_id in self.prompts[category]:
                    target_category = category
            else:
                # 搜索所有类别
                for cat, prompts in self.prompts.items():
                    if prompt_id in prompts:
                        target_category = cat
                        break
            
            if not target_category:
                print(f"未找到提示词: {prompt_id}")
                return False
            
            # 删除提示词
            del self.prompts[target_category][prompt_id]
            
            # 删除文件
            file_path = os.path.join(self.library_path, target_category, f"{prompt_id}.json")
            if os.path.exists(file_path):
                os.remove(file_path)
            
            # 检查YAML版本是否存在
            yaml_path = os.path.join(self.library_path, target_category, f"{prompt_id}.yaml")
            if os.path.exists(yaml_path):
                os.remove(yaml_path)
            
            # 检查yml版本是否存在
            yml_path = os.path.join(self.library_path, target_category, f"{prompt_id}.yml")
            if os.path.exists(yml_path):
                os.remove(yml_path)
            
            return True
        except Exception as e:
            print(f"删除提示词失败: {e}")
            return False
    
    def get_prompt(self, prompt_id: str, category: str = None) -> Optional[Dict[str, Any]]:
        """
        获取提示词内容
        
        Args:
            prompt_id: 提示词的唯一标识符
            category: 提示词所在的类别，如果未指定则搜索所有类别
            
        Returns:
            提示词信息，如果未找到则返回None
        """
        try:
            # 查找提示词
            if category:
                if category in self.prompts and prompt_id in self.prompts[category]:
                    return self.prompts[category][prompt_id].copy()
            else:
                # 搜索所有类别
                for cat, prompts in self.prompts.items():
                    if prompt_id in prompts:
                        return prompts[prompt_id].copy()
            
            return None
        except Exception as e:
            print(f"获取提示词失败: {e}")
            return None
    
    def search_prompts(self, query: str = None, tags: List[str] = None, 
                      category: str = None) -> List[Dict[str, Any]]:
        """
        搜索提示词
        
        Args:
            query: 搜索关键词
            tags: 标签过滤
            category: 类别过滤
            
        Returns:
            符合条件的提示词列表
        """
        results = []
        
        try:
            # 确定要搜索的类别
            search_categories = []
            if category:
                if category in self.prompts:
                    search_categories.append((category, self.prompts[category]))
            else:
                search_categories = list(self.prompts.items())
            
            # 搜索提示词
            for cat, prompts in search_categories:
                for prompt_id, prompt_info in prompts.items():
                    # 关键词搜索
                    if query:
                        query_lower = query.lower()
                        content_match = query_lower in prompt_info['content'].lower()
                        desc_match = query_lower in prompt_info['description'].lower()
                        id_match = query_lower in prompt_id.lower()
                        
                        # 检查元数据中的关键词
                        metadata_match = False
                        for key, value in prompt_info['metadata'].items():
                            if query_lower in str(key).lower() or query_lower in str(value).lower():
                                metadata_match = True
                                break
                        
                        if not (content_match or desc_match or id_match or metadata_match):
                            continue
                    
                    # 标签过滤
                    if tags:
                        if not any(tag.lower() in [t.lower() for t in prompt_info['tags']] for tag in tags):
                            continue
                    
                    # 添加到结果中
                    result = prompt_info.copy()
                    result['id'] = prompt_id
                    result['category'] = cat
                    results.append(result)
            
            # 按更新时间排序
            results.sort(key=lambda x: x['updated_at'], reverse=True)
            
            return results
        except Exception as e:
            print(f"搜索提示词失败: {e}")
            return []
    
    def export_prompt(self, prompt_id: str, output_file: str, format: str = 'json', 
                     category: str = None) -> bool:
        """
        导出提示词
        
        Args:
            prompt_id: 提示词的唯一标识符
            output_file: 输出文件路径
            format: 输出格式 (json, yaml)
            category: 提示词所在的类别，如果未指定则搜索所有类别
            
        Returns:
            是否导出成功
        """
        try:
            # 获取提示词
            prompt = self.get_prompt(prompt_id, category)
            if not prompt:
                return False
            
            # 添加ID到导出数据
            export_data = prompt.copy()
            export_data['id'] = prompt_id
            export_data['category'] = category or self._find_category(prompt_id)
            
            # 确保输出目录存在
            output_dir = os.path.dirname(output_file)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir, exist_ok=True)
            
            # 导出到文件
            with open(output_file, 'w', encoding='utf-8') as f:
                if format.lower() == 'yaml':
                    yaml.dump(export_data, f, default_flow_style=False, allow_unicode=True)
                else:
                    json.dump(export_data, f, indent=2, ensure_ascii=False)
            
            return True
        except Exception as e:
            print(f"导出提示词失败: {e}")
            return False
    
    def import_prompt(self, input_file: str, category: str = None, 
                     overwrite: bool = False) -> bool:
        """
        导入提示词
        
        Args:
            input_file: 输入文件路径
            category: 覆盖导入的类别
            overwrite: 是否覆盖已存在的提示词
            
        Returns:
            是否导入成功
        """
        try:
            # 加载文件内容
            if input_file.endswith('.json'):
                with open(input_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
            elif input_file.endswith('.yaml') or input_file.endswith('.yml'):
                with open(input_file, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f)
            else:
                print(f"不支持的文件格式: {input_file}")
                return False
            
            # 处理单个提示词
            if isinstance(data, dict) and 'id' in data:
                prompt_id = data['id']
                
                # 确定类别
                target_category = category or data.get('category', 'general')
                
                # 检查是否已存在
                if not overwrite:
                    existing_prompt = self.get_prompt(prompt_id, target_category)
                    if existing_prompt:
                        print(f"提示词已存在: {prompt_id}")
                        return False
                
                # 导入提示词
                return self.add_prompt(
                    prompt_id=prompt_id,
                    content=data.get('content', ''),
                    description=data.get('description', ''),
                    tags=data.get('tags', []),
                    category=target_category,
                    metadata=data.get('metadata', {})
                )
            
            # 处理提示词集合
            elif isinstance(data, list):
                success_count = 0
                for item in data:
                    if isinstance(item, dict) and 'id' in item:
                        result = self.import_prompt_from_dict(item, category, overwrite)
                        if result:
                            success_count += 1
                
                print(f"成功导入 {success_count}/{len(data)} 个提示词")
                return success_count > 0
            
            return False
        except Exception as e:
            print(f"导入提示词失败: {e}")
            return False
    
    def import_prompt_from_dict(self, data: Dict[str, Any], category: Optional[str] = None, 
                               overwrite: bool = False) -> bool:
        """
        从字典导入单个提示词
        """
        try:
            prompt_id = data['id']
            
            # 确定类别
            target_category = category or data.get('category', 'general')
            
            # 检查是否已存在
            if not overwrite:
                existing_prompt = self.get_prompt(prompt_id, target_category)
                if existing_prompt:
                    return False
            
            # 导入提示词
            return self.add_prompt(
                prompt_id=prompt_id,
                content=data.get('content', ''),
                description=data.get('description', ''),
                tags=data.get('tags', []),
                category=target_category,
                metadata=data.get('metadata', {})
            )
        except Exception as e:
            print(f"从字典导入提示词失败: {e}")
            return False
    
    def _save_prompt(self, category: str, prompt_id: str) -> None:
        """
        保存提示词到文件
        """
        try:
            # 确保类别目录存在
            category_path = os.path.join(self.library_path, category)
            os.makedirs(category_path, exist_ok=True)
            
            # 构建文件路径
            file_path = os.path.join(category_path, f"{prompt_id}.json")
            
            # 获取提示词信息
            prompt_info = self.prompts[category][prompt_id]
            
            # 保存为JSON
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump({
                    'prompt': prompt_info['content'],
                    'description': prompt_info['description'],
                    'tags': prompt_info['tags'],
                    'created_at': prompt_info['created_at'],
                    'updated_at': prompt_info['updated_at'],
                    'metadata': prompt_info['metadata']
                }, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存提示词失败 {prompt_id}: {e}")
    
    def _find_category(self, prompt_id: str) -> str:
        """
        查找提示词所在的类别
        """
        for category, prompts in self.prompts.items():
            if prompt_id in prompts:
                return category
        return 'general'
    
    def list_categories(self) -> List[str]:
        """
        列出所有可用的类别
        
        Returns:
            类别列表
        """
        return list(self.prompts.keys())
    
    def list_prompts(self, category: str = None) -> List[str]:
        """
        列出指定类别或所有类别的提示词ID
        
        Args:
            category: 类别，如果未指定则列出所有
            
        Returns:
            提示词ID列表
        """
        results = []
        
        if category:
            if category in self.prompts:
                results = list(self.prompts[category].keys())
        else:
            for cat_prompts in self.prompts.values():
                results.extend(cat_prompts.keys())
        
        return sorted(results)
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        获取提示词库的统计信息
        
        Returns:
            统计信息字典
        """
        stats = {
            'total_prompts': 0,
            'categories': {},
            'tags': {},
            'recent_updates': []
        }
        
        # 收集所有提示词信息
        all_prompts = []
        for category, prompts in self.prompts.items():
            stats['categories'][category] = len(prompts)
            stats['total_prompts'] += len(prompts)
            
            for prompt_id, prompt_info in prompts.items():
                # 收集标签统计
                for tag in prompt_info['tags']:
                    stats['tags'][tag] = stats['tags'].get(tag, 0) + 1
                
                # 准备最近更新列表
                all_prompts.append({
                    'id': prompt_id,
                    'category': category,
                    'updated_at': prompt_info['updated_at']
                })
        
        # 按更新时间排序，获取最近更新的提示词
        all_prompts.sort(key=lambda x: x['updated_at'], reverse=True)
        stats['recent_updates'] = all_prompts[:10]
        
        return stats

# 实用工具函数
def format_prompt_for_usage(prompt: Dict[str, Any], variables: Dict[str, Any] = None) -> str:
    """
    格式化提示词，替换变量占位符
    
    Args:
        prompt: 提示词信息
        variables: 变量字典
        
    Returns:
        格式化后的提示词内容
    """
    content = prompt['content']
    
    # 替换变量
    if variables:
        # 支持{{变量名}}格式的占位符
        for key, value in variables.items():
            content = content.replace(f"{{{{{key}}}}}", str(value))
    
    return content

def generate_prompt_suggestion(context: str, task_type: str = None) -> Dict[str, Any]:
    """
    根据上下文生成提示词建议
    
    Args:
        context: 上下文信息
        task_type: 任务类型
        
    Returns:
        建议的提示词信息
    """
    import openai
    
    try:
        # 构建提示词
        prompt = f"""
请为以下编程任务生成一个有效的提示词模板。

任务上下文:
```
{context}
```

{"任务类型: " + task_type + "\n" if task_type else ""}

请提供:
1. 一个有效的提示词模板
2. 对提示词的简短描述
3. 适用的标签（最多5个）
4. 提示词中应包含的变量占位符（如适用）
5. 使用该提示词的最佳实践

请以JSON格式返回，包含以下字段：
- prompt: 提示词模板
- description: 描述
- tags: 标签列表
- variables: 变量占位符列表（每个包含name和description）
- best_practices: 最佳实践列表

请确保JSON格式正确。
"""
        
        # 调用OpenAI API生成提示词建议
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "你是一位AI编程提示词专家，擅长创建高质量、有效的提示词模板。"},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            response_format={"type": "json_object"}
        )
        
        return json.loads(response.choices[0].message.content)
        
    except Exception as e:
        print(f"生成提示词建议失败: {e}")
        return None

def main():
    # 解析命令行参数
    parser = argparse.ArgumentParser(description="提示词库管理工具")
    parser.add_argument("--library", help="提示词库路径")
    
    subparsers = parser.add_subparsers(dest="command", help="可用命令")
    
    # 添加提示词命令
    add_parser = subparsers.add_parser("add", help="添加新提示词")
    add_parser.add_argument("--id", required=True, help="提示词ID")
    add_parser.add_argument("--content", required=True, help="提示词内容")
    add_parser.add_argument("--description", help="提示词描述")
    add_parser.add_argument("--tag", action="append", dest="tags", help="提示词标签")
    add_parser.add_argument("--category", default="general", help="提示词类别")
    
    # 更新提示词命令
    update_parser = subparsers.add_parser("update", help="更新提示词")
    update_parser.add_argument("--id", required=True, help="提示词ID")
    update_parser.add_argument("--content", help="新的提示词内容")
    update_parser.add_argument("--description", help="新的描述")
    update_parser.add_argument("--tag", action="append", dest="tags", help="新的标签")
    update_parser.add_argument("--category", help="提示词类别")
    
    # 删除提示词命令
    delete_parser = subparsers.add_parser("delete", help="删除提示词")
    delete_parser.add_argument("--id", required=True, help="提示词ID")
    delete_parser.add_argument("--category", help="提示词类别")
    
    # 获取提示词命令
    get_parser = subparsers.add_parser("get", help="获取提示词")
    get_parser.add_argument("--id", required=True, help="提示词ID")
    get_parser.add_argument("--category", help="提示词类别")
    
    # 搜索提示词命令
    search_parser = subparsers.add_parser("search", help="搜索提示词")
    search_parser.add_argument("--query", help="搜索关键词")
    search_parser.add_argument("--tag", action="append", dest="tags", help="标签过滤")
    search_parser.add_argument("--category", help="类别过滤")
    
    # 列出提示词命令
    list_parser = subparsers.add_parser("list", help="列出提示词")
    list_parser.add_argument("--category", help="类别过滤")
    
    # 导出提示词命令
    export_parser = subparsers.add_parser("export", help="导出提示词")
    export_parser.add_argument("--id", required=True, help="提示词ID")
    export_parser.add_argument("--output", required=True, help="输出文件路径")
    export_parser.add_argument("--format", default="json", choices=["json", "yaml"], help="输出格式")
    export_parser.add_argument("--category", help="提示词类别")
    
    # 导入提示词命令
    import_parser = subparsers.add_parser("import", help="导入提示词")
    import_parser.add_argument("--input", required=True, help="输入文件路径")
    import_parser.add_argument("--category", help="覆盖的类别")
    import_parser.add_argument("--overwrite", action="store_true", help="覆盖已存在的提示词")
    
    # 生成提示词建议命令
    suggest_parser = subparsers.add_parser("suggest", help="生成提示词建议")
    suggest_parser.add_argument("--context", required=True, help="上下文信息")
    suggest_parser.add_argument("--task-type", help="任务类型")
    suggest_parser.add_argument("--save", help="保存为提示词ID")
    suggest_parser.add_argument("--category", default="general", help="保存的类别")
    
    # 统计信息命令
    stats_parser = subparsers.add_parser("stats", help="获取统计信息")
    
    args = parser.parse_args()
    
    # 初始化提示词库管理器
    manager = PromptLibraryManager(args.library)
    
    if args.command == "add":
        # 添加提示词
        success = manager.add_prompt(
            prompt_id=args.id,
            content=args.content,
            description=args.description or "",
            tags=args.tags or [],
            category=args.category
        )
        if success:
            print(f"提示词 '{args.id}' 已添加到 {args.category} 类别")
        else:
            print("添加失败")
    
    elif args.command == "update":
        # 更新提示词
        success = manager.update_prompt(
            prompt_id=args.id,
            content=args.content,
            description=args.description,
            tags=args.tags,
            category=args.category
        )
        if success:
            print(f"提示词 '{args.id}' 已更新")
        else:
            print("更新失败")
    
    elif args.command == "delete":
        # 删除提示词
        success = manager.delete_prompt(
            prompt_id=args.id,
            category=args.category
        )
        if success:
            print(f"提示词 '{args.id}' 已删除")
        else:
            print("删除失败")
    
    elif args.command == "get":
        # 获取提示词
        prompt = manager.get_prompt(
            prompt_id=args.id,
            category=args.category
        )
        if prompt:
            print(f"ID: {args.id}")
            print(f"类别: {args.category or manager._find_category(args.id)}")
            print(f"描述: {prompt['description']}")
            print(f"标签: {', '.join(prompt['tags'])}")
            print(f"创建时间: {prompt['created_at']}")
            print(f"更新时间: {prompt['updated_at']}")
            print(f"\n内容:\n{prompt['content']}")
        else:
            print(f"未找到提示词: {args.id}")
    
    elif args.command == "search":
        # 搜索提示词
        results = manager.search_prompts(
            query=args.query,
            tags=args.tags,
            category=args.category
        )
        print(f"找到 {len(results)} 个匹配的提示词")
        for i, result in enumerate(results, 1):
            print(f"\n{i}. {result['id']} (类别: {result['category']})")
            print(f"   描述: {result['description']}")
            print(f"   标签: {', '.join(result['tags'])}")
            print(f"   更新时间: {result['updated_at']}")
    
    elif args.command == "list":
        # 列出提示词
        prompts = manager.list_prompts(args.category)
        print(f"{args.category + ' 类别中的' if args.category else ''}提示词列表 ({len(prompts)} 个):")
        for prompt_id in prompts:
            print(f"- {prompt_id}")
    
    elif args.command == "export":
        # 导出提示词
        success = manager.export_prompt(
            prompt_id=args.id,
            output_file=args.output,
            format=args.format,
            category=args.category
        )
        if success:
            print(f"提示词 '{args.id}' 已导出到 {args.output}")
        else:
            print("导出失败")
    
    elif args.command == "import":
        # 导入提示词
        success = manager.import_prompt(
            input_file=args.input,
            category=args.category,
            overwrite=args.overwrite
        )
        if success:
            print(f"提示词已从 {args.input} 导入")
        else:
            print("导入失败")
    
    elif args.command == "suggest":
        # 生成提示词建议
        suggestion = generate_prompt_suggestion(args.context, args.task_type)
        if suggestion:
            print(f"\n提示词建议:")
            print(f"描述: {suggestion['description']}")
            print(f"标签: {', '.join(suggestion['tags'])}")
            print(f"\n内容:\n{suggestion['prompt']}")
            
            # 保存提示词
            if args.save:
                success = manager.add_prompt(
                    prompt_id=args.save,
                    content=suggestion['prompt'],
                    description=suggestion['description'],
                    tags=suggestion['tags'],
                    category=args.category
                )
                if success:
                    print(f"\n提示词已保存为 '{args.save}'")
        else:
            print("生成提示词建议失败")
    
    elif args.command == "stats":
        # 获取统计信息
        stats = manager.get_statistics()
        print(f"总提示词数: {stats['total_prompts']}")
        print(f"\n类别统计:")
        for category, count in stats['categories'].items():
            print(f"- {category}: {count}")
        
        print(f"\n热门标签:")
        # 按使用次数排序
        sorted_tags = sorted(stats['tags'].items(), key=lambda x: x[1], reverse=True)[:10]
        for tag, count in sorted_tags:
            print(f"- {tag}: {count}")
        
        print(f"\n最近更新的提示词:")
        for item in stats['recent_updates']:
            print(f"- {item['id']} (类别: {item['category']}, 更新于: {item['updated_at']})")
    
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
```

### 提示词模板的设计与使用

一个好的提示词模板应该具有通用性和可定制性。以下是一些常用的提示词模板示例：

```python
# 提示词模板集合
def get_prompt_template(template_name: str) -> Dict[str, Any]:
    """
    获取预定义的提示词模板
    
    Args:
        template_name: 模板名称
        
    Returns:
        提示词模板信息
    """
    templates = {
        # 代码生成模板
        "code_generation": {
            "prompt": "请实现一个函数，该函数能够{{description}}。函数应该满足以下要求：\n{{requirements}}\n\n请提供完整的代码实现，并添加详细的注释。",
            "description": "通用代码生成模板",
            "tags": ["code", "generation", "function"]
        },
        
        # 代码审查模板
        "code_review": {
            "prompt": "请审查以下代码，找出潜在的问题、优化机会和最佳实践建议。\n\n```{{language}}\n{{code}}\n```\n\n请从以下几个方面进行审查：\n1. 代码质量和可读性\n2. 潜在的错误和边界情况\n3. 性能优化机会\n4. 安全性考虑\n5. 最佳实践建议",
            "description": "代码审查模板",
            "tags": ["code", "review", "quality"]
        },
        
        # 错误调试模板
        "error_debugging": {
            "prompt": "请帮助我调试以下错误。错误信息如下：\n```\n{{error_message}}\n```\n\n相关代码片段：\n```{{language}}\n{{code}}\n```\n\n请分析错误原因并提供修复建议。",
            "description": "错误调试模板",
            "tags": ["debugging", "error", "fix"]
        },
        
        # 算法解释模板
        "algorithm_explanation": {
            "prompt": "请解释{{algorithm_name}}算法的工作原理。\n\n请包括：\n1. 算法的基本思想\n2. 工作步骤\n3. 时间和空间复杂度分析\n4. 一个Python实现示例\n5. 适用场景和局限性",
            "description": "算法解释模板",
            "tags": ["algorithm", "explanation", "complexity"]
        },
        
        # API设计模板
        "api_design": {
            "prompt": "请为{{feature}}功能设计一个RESTful API。\n\n需求描述：\n{{requirements}}\n\n请提供：\n1. API端点设计\n2. 请求和响应格式\n3. 错误处理策略\n4. 安全性考虑\n5. 一个简单的实现示例",
            "description": "API设计模板",
            "tags": ["api", "design", "rest"]
        },
        
        # 重构建议模板
        "refactoring_suggestions": {
            "prompt": "请提供重构以下代码的建议，以提高其可维护性、可读性和性能。\n\n```{{language}}\n{{code}}\n```\n\n请提供：\n1. 当前代码的问题分析\n2. 具体的重构建议\n3. 重构后的代码示例\n4. 重构带来的好处",
            "description": "代码重构建议模板",
            "tags": ["refactoring", "code", "improvement"]
        },
        
        # 代码注释模板
        "code_documentation": {
            "prompt": "请为以下代码添加详细的注释和文档字符串。\n\n```{{language}}\n{{code}}\n```\n\n请包括：\n1. 函数/类的用途和功能描述\n2. 参数说明（类型、含义、默认值）\n3. 返回值说明\n4. 异常说明\n5. 使用示例（如有必要）",
            "description": "代码文档生成模板",
            "tags": ["documentation", "comments", "api"]
        },
        
        # 单元测试模板
        "unit_test_generation": {
            "prompt": "请为以下代码生成全面的单元测试。\n\n```{{language}}\n{{code}}\n```\n\n请包括：\n1. 正常情况的测试\n2. 边界情况的测试\n3. 异常情况的测试\n4. 测试覆盖尽可能多的代码路径\n\n使用{{test_framework}}框架。",
            "description": "单元测试生成模板",
            "tags": ["testing", "unit_test", "quality"]
        },
        
        # 性能优化模板
        "performance_optimization": {
            "prompt": "请分析并优化以下代码的性能。\n\n```{{language}}\n{{code}}\n```\n\n当前性能瓶颈：\n{{bottlenecks}}\n\n请提供：\n1. 性能问题的详细分析\n2. 具体的优化建议\n3. 优化后的代码实现\n4. 预期的性能提升\n5. 优化可能带来的副作用",
            "description": "性能优化模板",
            "tags": ["performance", "optimization", "efficiency"]
        },
        
        # 架构设计模板
        "architecture_design": {
            "prompt": "请为{{project_name}}项目设计一个合适的架构。\n\n项目需求：\n{{requirements}}\n\n技术栈限制：\n{{tech_stack}}\n\n请提供：\n1. 高层次架构图描述\n2. 关键组件和模块的说明\n3. 数据流和交互方式\n4. 扩展性和可维护性考虑\n5. 安全和性能考量",
            "description": "架构设计模板",
            "tags": ["architecture", "design", "system"]
        }
    }
    
    return templates.get(template_name)
```

## 6.4.2 针对特定领域的提示优化

不同的编程领域有其特定的需求和最佳实践。针对特定领域优化提示词可以提高AI生成代码的质量和相关性。

### 前端开发领域的提示优化

前端开发涉及HTML、CSS、JavaScript等技术，有其独特的挑战和模式。以下是一个针对前端开发的提示优化示例：

```python
#!/usr/bin/env python3
# frontend_prompt_optimizer.py - 前端开发提示词优化工具

import os
import sys
import json
import re
from typing import Dict, Any, List

class FrontendPromptOptimizer:
    """
    前端开发提示词优化器，用于生成针对前端开发的高质量提示词
    """
    
    # 前端框架和库的特定最佳实践
    FRAMEWORK_BEST_PRACTICES = {
        "react": [
            "使用函数组件和Hooks而非类组件",
            "实现组件的性能优化（使用React.memo, useMemo, useCallback）",
            "遵循单向数据流原则",
            "组件命名使用PascalCase，文件命名与组件名保持一致",
            "状态管理使用合适的工具（如React Context, Redux, Zustand等）",
            "处理副作用使用useEffect，并正确设置依赖项",
            "使用TypeScript为组件添加类型定义",
            "组件结构合理，职责单一"
        ],
        "vue": [
            "使用Composition API（Vue 3）而非Options API",
            "组件命名使用kebab-case，文件名与组件名保持一致",
            "使用setup函数组织逻辑",
            "使用ref和reactive管理响应式状态",
            "合理使用计算属性和监听器",
            "遵循Vue的单向数据流原则",
            "使用TypeScript增强类型安全",
            "组件拆分合理，职责单一"
        ],
        "angular": [
            "使用组件化架构，组件职责单一",
            "使用依赖注入管理服务和依赖",
            "使用RxJS处理异步操作和数据流",
            "使用模板驱动或响应式表单进行表单处理",
            "使用NgModule组织应用结构",
            "实现组件间的高效通信",
            "遵循TypeScript最佳实践",
            "合理使用生命周期钩子"
        ],
        "vanilla": [
            "使用现代JavaScript特性（ES6+）",
            "避免全局变量污染",
            "使用模块化开发（ES modules）",
            "DOM操作高效，避免不必要的重绘和回流",
            "事件处理合理，避免内存泄漏",
            "错误处理完善",
            "代码组织清晰，函数职责单一",
            "性能优化（防抖、节流等）"
        ]
    }
    
    # UI/UX设计考虑因素
    UI_UX_CONSIDERATIONS = [
        "响应式设计，适配不同屏幕尺寸",
        "可访问性支持（ARIA属性，键盘导航等）",
        "良好的用户体验（加载状态、错误处理、空状态等）",
        "视觉层次清晰，交互反馈及时",
        "动画效果流畅自然，不影响性能",
        "颜色对比度符合可访问性标准",
        "字体大小和行高合理，提高可读性",
        "用户操作路径简洁直观"
    ]
    
    # 前端性能优化策略
    PERFORMANCE_OPTIMIZATIONS = [
        "组件懒加载和代码分割",
        "图片优化（懒加载、适当尺寸、WebP格式等）",
        "资源缓存策略",
        "减少不必要的重渲染",
        "CSS优化（避免!important，合理使用选择器等）",
        "JavaScript执行优化（避免阻塞主线程）",
        "第三方库的合理使用和优化",
        "网络请求优化（批量请求、请求缓存等）"
    ]
    
    @staticmethod
    def optimize_react_prompt(requirement: str, component_type: str = None, 
                           complexity: str = "medium", include_ui: bool = True) -> str:
        """
        优化React开发的提示词
        
        Args:
            requirement: 原始需求描述
            component_type: 组件类型（如form, table, modal等）
            complexity: 复杂度（simple, medium, complex）
            include_ui: 是否包含UI/UX考虑
            
        Returns:
            优化后的提示词
        """
        prompt = f"""
请基于以下需求，使用React实现一个高质量的前端组件或功能。

原始需求:
{requirement}

{"组件类型: " + component_type + "\n" if component_type else ""}
{"复杂度: " + complexity + "\n" if complexity else ""}

请遵循以下React最佳实践：
{"\n".join([f"- {practice}" for practice in FrontendPromptOptimizer.FRAMEWORK_BEST_PRACTICES["react"]])}

{f"\n请考虑以下UI/UX设计因素：\n{"\n".join([f"- {consideration}" for consideration in FrontendPromptOptimizer.UI_UX_CONSIDERATIONS])}" if include_ui else ""}

请提供：
1. 完整的组件实现代码
2. 必要的类型定义（使用TypeScript）
3. 详细的注释说明
4. 使用示例

请确保代码：
- 可直接运行，无需额外修改
- 包含适当的错误处理
- 代码风格一致，可读性高
- 考虑性能、安全和可维护性
}

## 6.4.3 AI辅助编程工作流的自动化与集成

将AI辅助编程工具集成到开发工作流中，可以显著提高开发效率。下面介绍如何使用Python创建一个自动化工作流工具，帮助开发者更高效地利用AI编程助手。

```python
#!/usr/bin/env python3
# ai_programming_workflow.py - AI辅助编程工作流自动化工具

import os
import sys
import json
import subprocess
import re
from typing import Dict, Any, List, Optional
from datetime import datetime

# 导入之前创建的提示词库管理器
from prompt_library_manager import PromptLibraryManager

class AIWorkflowAutomator:
    """
    AI辅助编程工作流自动化工具，用于集成AI工具到开发流程中
    """
    
    def __init__(self, prompt_library_path: str = None):
        """
        初始化工作流自动化工具
        
        Args:
            prompt_library_path: 提示词库路径
        """
        self.prompt_library = PromptLibraryManager(prompt_library_path)
        self.workflow_history = []
        self.config = {
            "editor": os.environ.get("EDITOR", "vim"),
            "ai_api_key": os.environ.get("AI_API_KEY"),
            "default_model": "gpt-4",
            "code_dir": os.getcwd()
        }
    
    def load_config(self, config_file: str = ".ai_workflow_config.json") -> bool:
        """
        从配置文件加载配置
        
        Args:
            config_file: 配置文件路径
            
        Returns:
            是否成功加载配置
        """
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    self.config.update(loaded_config)
                return True
            return False
        except Exception as e:
            print(f"加载配置失败: {e}")
            return False
    
    def save_config(self, config_file: str = ".ai_workflow_config.json") -> bool:
        """
        保存配置到文件
        
        Args:
            config_file: 配置文件路径
            
        Returns:
            是否成功保存配置
        """
        try:
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"保存配置失败: {e}")
            return False
    
    def detect_file_type(self, file_path: str) -> str:
        """
        检测文件类型
        
        Args:
            file_path: 文件路径
            
        Returns:
            文件类型
        """
        extension = os.path.splitext(file_path)[1].lower()
        
        file_types = {
            ".py": "python",
            ".js": "javascript",
            ".ts": "typescript",
            ".jsx": "javascriptreact",
            ".tsx": "typescriptreact",
            ".html": "html",
            ".css": "css",
            ".scss": "scss",
            ".json": "json",
            ".yaml": "yaml",
            ".yml": "yaml",
            ".md": "markdown",
            ".sh": "shell",
            ".go": "go",
            ".java": "java",
            ".c": "c",
            ".cpp": "cpp",
            ".h": "c",
            ".hpp": "cpp",
            ".rs": "rust",
            ".php": "php",
            ".rb": "ruby"
        }
        
        return file_types.get(extension, "text")
    
    def read_file_content(self, file_path: str) -> Optional[str]:
        """
        读取文件内容
        
        Args:
            file_path: 文件路径
            
        Returns:
            文件内容
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            print(f"读取文件失败 {file_path}: {e}")
            return None
    
    def write_file_content(self, file_path: str, content: str) -> bool:
        """
        写入文件内容
        
        Args:
            file_path: 文件路径
            content: 文件内容
            
        Returns:
            是否成功写入
        """
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        except Exception as e:
            print(f"写入文件失败 {file_path}: {e}")
            return False
    
    def run_ai_task(self, task_type: str, content: str, **kwargs) -> Optional[Dict[str, Any]]:
        """
        运行AI任务
        
        Args:
            task_type: 任务类型
            content: 任务内容
            **kwargs: 额外参数
            
        Returns:
            AI响应结果
        """
        import openai
        
        # 设置API密钥
        openai.api_key = self.config["ai_api_key"]
        
        try:
            # 根据任务类型选择提示词模板
            template_id = f"{task_type}_template"
            template = self.prompt_library.get_prompt(template_id, "workflow")
            
            # 如果没有找到模板，使用默认模板
            if not template:
                # 默认提示词模板
                default_templates = {
                    "code_generation": "请生成满足以下需求的代码:\n{content}",
                    "code_review": "请审查以下代码，找出问题并提供改进建议:\n```\n{content}\n```",
                    "bug_fix": "请修复以下代码中的bug:\n```\n{content}\n```\n\n错误描述: {error_message}",
                    "documentation": "请为以下代码生成详细的文档:\n```\n{content}\n```",
                    "refactoring": "请重构以下代码以提高其质量:\n```\n{content}\n```\n\n改进目标: {goals}"
                }
                
                prompt_template = default_templates.get(task_type, "请处理以下内容:\n{content}")
                prompt_content = prompt_template.format(content=content, **kwargs)
            else:
                # 使用模板
                variables = {"content": content, **kwargs}
                prompt_content = template["content"].format(**variables)
            
            # 调用OpenAI API
            response = openai.ChatCompletion.create(
                model=self.config["default_model"],
                messages=[
                    {"role": "system", "content": "你是一位专业的AI编程助手。"},
                    {"role": "user", "content": prompt_content}
                ],
                temperature=0.3
            )
            
            result = {
                "task_type": task_type,
                "timestamp": datetime.now().isoformat(),
                "prompt": prompt_content,
                "response": response.choices[0].message.content
            }
            
            # 保存到历史记录
            self.workflow_history.append(result)
            
            return result
            
        except Exception as e:
            print(f"运行AI任务失败: {e}")
            return None
    
    def extract_code_from_response(self, response: str) -> Optional[str]:
        """
        从AI响应中提取代码
        
        Args:
            response: AI响应内容
            
        Returns:
            提取的代码
        """
        # 使用正则表达式匹配代码块
        code_pattern = r"```(?:[a-zA-Z0-9]+)?\n([\s\S]*?)\n```"
        match = re.search(code_pattern, response)
        
        if match:
            return match.group(1)
        
        return None
    
    def integrate_with_vcs(self, file_path: str) -> bool:
        """
        与版本控制系统集成
        
        Args:
            file_path: 文件路径
            
        Returns:
            是否成功集成
        """
        try:
            # 检查是否在git仓库中
            if os.path.exists(".git"):
                # 运行git add命令
                subprocess.run(["git", "add", file_path], check=True)
                print(f"已将 {file_path} 添加到git暂存区")
                return True
            return False
        except Exception as e:
            print(f"与版本控制系统集成失败: {e}")
            return False
    
    def create_commit_message(self, file_path: str, change_type: str) -> Optional[str]:
        """
        生成提交消息
        
        Args:
            file_path: 文件路径
            change_type: 更改类型
            
        Returns:
            生成的提交消息
        """
        file_content = self.read_file_content(file_path)
        if not file_content:
            return None
        
        # 获取文件类型
        file_type = self.detect_file_type(file_path)
        
        # 构建提示词
        prompt = f"""
请为以下代码更改生成一个简洁明了的git提交消息。

文件类型: {file_type}
文件路径: {file_path}
更改类型: {change_type}

文件内容预览:
```
{file_content[:500]}...
```

请生成一个遵循约定式提交规范的提交消息，格式为:
<类型>[可选作用域]: <描述>

其中类型可以是: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

消息应该简明扼要，不超过50个字符。
"""
        
        # 调用AI生成提交消息
        result = self.run_ai_task("commit_message", prompt)
        if result:
            return result["response"].strip()
        
        return None
    
    def setup_project_workflow(self, project_dir: str) -> bool:
        """
        设置项目工作流
        
        Args:
            project_dir: 项目目录
            
        Returns:
            是否成功设置
        """
        try:
            # 创建配置文件
            config_path = os.path.join(project_dir, ".ai_workflow_config.json")
            
            # 获取项目信息
            project_name = os.path.basename(project_dir)
            
            # 检测项目类型
            project_type = "general"
            if os.path.exists(os.path.join(project_dir, "package.json")):
                project_type = "javascript"
            elif os.path.exists(os.path.join(project_dir, "requirements.txt")) or os.path.exists(os.path.join(project_dir, "setup.py")):
                project_type = "python"
            elif os.path.exists(os.path.join(project_dir, "go.mod")):
                project_type = "go"
            elif os.path.exists(os.path.join(project_dir, "pom.xml")):
                project_type = "java"
            
            # 创建工作流配置
            workflow_config = {
                "project_name": project_name,
                "project_type": project_type,
                "created_at": datetime.now().isoformat(),
                "workflows": [
                    {
                        "name": "code_generation",
                        "trigger": "manual",
                        "template": "code_generation_template"
                    },
                    {
                        "name": "code_review",
                        "trigger": "pre_commit",
                        "template": "code_review_template"
                    },
                    {
                        "name": "documentation",
                        "trigger": "post_commit",
                        "template": "documentation_template"
                    }
                ]
            }
            
            # 保存配置
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(workflow_config, f, indent=2, ensure_ascii=False)
            
            # 创建提示词库目录
            prompt_library_dir = os.path.join(project_dir, ".ai_prompts")
            os.makedirs(prompt_library_dir, exist_ok=True)
            
            # 创建默认提示词模板
            default_templates = {
                "code_generation_template": {
                    "content": "请为{project_name}项目生成满足以下需求的{project_type}代码:\n{content}\n\n请确保代码符合项目的编码规范和最佳实践。",
                    "description": "代码生成模板",
                    "tags": ["code", "generation"]
                },
                "code_review_template": {
                    "content": "请审查以下{project_type}代码，找出潜在问题和改进建议:\n```\n{content}\n```\n\n请特别关注代码质量、性能和安全性。",
                    "description": "代码审查模板",
                    "tags": ["code", "review"]
                },
                "documentation_template": {
                    "content": "请为以下{project_type}代码生成详细的文档:\n```\n{content}\n```\n\n文档应包括功能描述、参数说明、返回值和使用示例。",
                    "description": "文档生成模板",
                    "tags": ["documentation"]
                }
            }
            
            # 初始化项目提示词库
            project_prompt_manager = PromptLibraryManager(prompt_library_dir)
            for template_id, template_info in default_templates.items():
                project_prompt_manager.add_prompt(
                    prompt_id=template_id,
                    content=template_info["content"].format(project_name=project_name, project_type=project_type),
                    description=template_info["description"],
                    tags=template_info["tags"],
                    category="workflow"
                )
            
            print(f"已成功设置项目工作流: {project_dir}")
            return True
            
        except Exception as e:
            print(f"设置项目工作流失败: {e}")
            return False
    
    def analyze_codebase(self, code_dir: str) -> Dict[str, Any]:
        """
        分析代码库
        
        Args:
            code_dir: 代码目录
            
        Returns:
            代码库分析结果
        """
        analysis = {
            "total_files": 0,
            "file_types": {},
            "total_lines": 0,
            "directories": [],
            "large_files": [],
            "recent_files": []
        }
        
        file_info_list = []
        
        try:
            for root, dirs, files in os.walk(code_dir):
                # 排除隐藏目录
                dirs[:] = [d for d in dirs if not d.startswith('.')]
                
                analysis["directories"].extend([os.path.join(root, d) for d in dirs])
                
                for file in files:
                    # 排除隐藏文件
                    if file.startswith('.'):
                        continue
                    
                    file_path = os.path.join(root, file)
                    file_type = self.detect_file_type(file_path)
                    
                    # 更新文件类型统计
                    analysis["file_types"][file_type] = analysis["file_types"].get(file_type, 0) + 1
                    analysis["total_files"] += 1
                    
                    # 获取文件信息
                    try:
                        file_size = os.path.getsize(file_path)
                        file_mtime = os.path.getmtime(file_path)
                        
                        # 计算文件行数
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            line_count = sum(1 for _ in f)
                        
                        analysis["total_lines"] += line_count
                        
                        # 记录大文件（> 1000行）
                        if line_count > 1000:
                            analysis["large_files"].append({
                                "path": file_path,
                                "lines": line_count
                            })
                        
                        # 保存文件信息用于后续处理
                        file_info_list.append({
                            "path": file_path,
                            "type": file_type,
                            "size": file_size,
                            "lines": line_count,
                            "mtime": file_mtime
                        })
                        
                    except Exception as e:
                        # 忽略无法处理的文件
                        continue
            
            # 排序并获取最近修改的文件
            file_info_list.sort(key=lambda x: x["mtime"], reverse=True)
            analysis["recent_files"] = [
                {
                    "path": f["path"],
                    "type": f["type"],
                    "modified": datetime.fromtimestamp(f["mtime"]).strftime("%Y-%m-%d %H:%M:%S")
                }
                for f in file_info_list[:20]
            ]
            
            return analysis
            
        except Exception as e:
            print(f"分析代码库失败: {e}")
            return analysis

# 命令行接口
def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="AI辅助编程工作流自动化工具")
    parser.add_argument("--config", help="配置文件路径")
    
    subparsers = parser.add_subparsers(dest="command", help="可用命令")
    
    # 初始化命令
    init_parser = subparsers.add_parser("init", help="初始化项目工作流")
    init_parser.add_argument("project_dir", default=".", help="项目目录")
    
    # 代码生成命令
    generate_parser = subparsers.add_parser("generate", help="生成代码")
    generate_parser.add_argument("--prompt", required=True, help="生成提示")
    generate_parser.add_argument("--output", help="输出文件路径")
    generate_parser.add_argument("--language", help="编程语言")
    
    # 代码审查命令
    review_parser = subparsers.add_parser("review", help="审查代码")
    review_parser.add_argument("file_path", help="要审查的文件路径")
    
    # 修复bug命令
    fix_parser = subparsers.add_parser("fix", help="修复代码中的bug")
    fix_parser.add_argument("file_path", help="要修复的文件路径")
    fix_parser.add_argument("--error", required=True, help="错误描述")
    fix_parser.add_argument("--output", help="输出文件路径")
    
    # 文档生成命令
    doc_parser = subparsers.add_parser("document", help="生成文档")
    doc_parser.add_argument("file_path", help="要生成文档的文件路径")
    doc_parser.add_argument("--output", help="输出文件路径")
    
    # 重构命令
    refactor_parser = subparsers.add_parser("refactor", help="重构代码")
    refactor_parser.add_argument("file_path", help="要重构的文件路径")
    refactor_parser.add_argument("--goals", required=True, help="重构目标")
    refactor_parser.add_argument("--output", help="输出文件路径")
    
    # 代码库分析命令
    analyze_parser = subparsers.add_parser("analyze", help="分析代码库")
    analyze_parser.add_argument("code_dir", default=".", help="代码目录")
    
    # 生成提交消息命令
    commit_parser = subparsers.add_parser("commit", help="生成提交消息")
    commit_parser.add_argument("file_path", help="文件路径")
    commit_parser.add_argument("--type", default="feat", help="更改类型")
    
    args = parser.parse_args()
    
    # 初始化工作流自动化工具
    automator = AIWorkflowAutomator()
    
    # 加载配置
    if args.config:
        automator.load_config(args.config)
    else:
        automator.load_config()
    
    if args.command == "init":
        # 初始化项目工作流
        automator.setup_project_workflow(args.project_dir)
    
    elif args.command == "generate":
        # 生成代码
        result = automator.run_ai_task("code_generation", args.prompt, language=args.language)
        if result:
            if args.output:
                # 提取代码并保存
                code = automator.extract_code_from_response(result["response"])
                if code:
                    automator.write_file_content(args.output, code)
                    print(f"代码已生成到: {args.output}")
                else:
                    print("无法从响应中提取代码")
            else:
                print("生成的代码:")
                print(result["response"])
    
    elif args.command == "review":
        # 审查代码
        content = automator.read_file_content(args.file_path)
        if content:
            result = automator.run_ai_task("code_review", content)
            if result:
                print("代码审查结果:")
                print(result["response"])
    
    elif args.command == "fix":
        # 修复bug
        content = automator.read_file_content(args.file_path)
        if content:
            result = automator.run_ai_task("bug_fix", content, error_message=args.error)
            if result:
                if args.output:
                    # 提取修复后的代码并保存
                    code = automator.extract_code_from_response(result["response"])
                    if code:
                        automator.write_file_content(args.output, code)
                        print(f"修复后的代码已保存到: {args.output}")
                    else:
                        print("无法从响应中提取代码")
                else:
                    print("修复建议:")
                    print(result["response"])
    
    elif args.command == "document":
        # 生成文档
        content = automator.read_file_content(args.file_path)
        if content:
            result = automator.run_ai_task("documentation", content)
            if result:
                if args.output:
                    automator.write_file_content(args.output, result["response"])
                    print(f"文档已生成到: {args.output}")
                else:
                    print("生成的文档:")
                    print(result["response"])
    
    elif args.command == "refactor":
        # 重构代码
        content = automator.read_file_content(args.file_path)
        if content:
            result = automator.run_ai_task("refactoring", content, goals=args.goals)
            if result:
                if args.output:
                    # 提取重构后的代码并保存
                    code = automator.extract_code_from_response(result["response"])
                    if code:
                        automator.write_file_content(args.output, code)
                        print(f"重构后的代码已保存到: {args.output}")
                    else:
                        print("无法从响应中提取代码")
                else:
                    print("重构建议:")
                    print(result["response"])
    
    elif args.command == "analyze":
        # 分析代码库
        analysis = automator.analyze_codebase(args.code_dir)
        print(f"代码库分析结果:")
        print(f"总文件数: {analysis['total_files']}")
        print(f"总行数: {analysis['total_lines']}")
        print(f"\n文件类型统计:")
        for file_type, count in analysis['file_types'].items():
            print(f"- {file_type}: {count}")
        print(f"\n大型文件 (> 1000行):")
        for file in analysis['large_files'][:10]:  # 只显示前10个
            print(f"- {file['path']}: {file['lines']}行")
        print(f"\n最近修改的文件:")
        for file in analysis['recent_files'][:10]:  # 只显示前10个
            print(f"- {file['path']} ({file['type']}): {file['modified']}")
    
    elif args.command == "commit":
        # 生成提交消息
        commit_msg = automator.create_commit_message(args.file_path, args.type)
        if commit_msg:
            print(f"建议的提交消息:")
            print(commit_msg)
    
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
```

### 工作流集成示例

将AI编程工具集成到开发环境中的几种常见方式：

1. **编辑器插件集成**：通过VSCode、PyCharm等IDE的插件系统，将AI编程工具直接集成到编辑器中，实现代码补全、错误修复等功能的实时访问。

2. **Git Hooks集成**：使用Git的pre-commit、pre-push等钩子，在代码提交或推送前自动运行AI代码审查、格式化等工具，确保代码质量。

3. **CI/CD流水线集成**：在持续集成/持续部署流水线中添加AI工具的检查步骤，如代码质量分析、安全扫描等，作为构建或部署的前置条件。

4. **命令行工具链**：创建命令行工具，通过别名或脚本集成到开发工作流中，便于在任何环境下使用。

## 总结与实践

通过本章节的学习，我们了解了如何构建个人AI编程系统，包括：

1. **提示词库的建立与管理**：创建了一个完整的提示词库管理工具，可以有效地组织、搜索和使用提示词，提高AI编程助手的使用效率。

2. **针对特定领域的提示优化**：学习了如何为前端、后端等不同编程领域优化提示词，使生成的代码更符合特定领域的最佳实践和要求。

3. **AI辅助编程工作流的自动化与集成**：构建了一个工作流自动化工具，可以将AI编程助手无缝集成到开发流程中，实现代码生成、审查、修复等任务的自动化。

### 实践建议

1. **持续收集和优化提示词**：在日常编程工作中，不断收集有效的提示词，并根据使用效果进行优化。

2. **定制化提示词模板**：针对自己常用的编程任务和领域，创建定制化的提示词模板，提高工作效率。

3. **自动化重复性工作**：识别工作中重复性高的任务，使用AI工具自动化处理，如代码格式化、文档生成等。

4. **定期回顾和改进**：定期回顾使用AI编程助手的效果，分析哪些任务适合自动化，哪些需要人工干预，不断优化工作流。

通过构建个人AI编程系统，开发者可以显著提高编程效率，专注于更有创造性的工作，充分发挥AI编程助手的潜力。

---

### 思考与练习

1. 尝试基于本章提供的代码，构建一个适合自己的提示词库管理系统，并添加一些个性化功能。

2. 为你最常用的编程领域（如React开发、Python数据分析等）创建一套专门的提示词模板。

3. 设计一个工作流，将AI编程工具集成到你的日常开发环境中，解决实际工作中的痛点。

4. 思考如何评估AI生成代码的质量，以及如何建立一个反馈机制来持续改进你的提示词。
"""
        
        return prompt
    
    @staticmethod
    def optimize_vue_prompt(requirement: str, component_type: str = None, 
                          complexity: str = "medium", include_ui: bool = True) -> str:
        """
        优化Vue开发的提示词
        
        Args:
            requirement: 原始需求描述
            component_type: 组件类型
            complexity: 复杂度
            include_ui: 是否包含UI/UX考虑
            
        Returns:
            优化后的提示词
        """
        prompt = f"""
请基于以下需求，使用Vue实现一个高质量的前端组件或功能。

原始需求:
{requirement}

{"组件类型: " + component_type + "\n" if component_type else ""}
{"复杂度: " + complexity + "\n" if complexity else ""}

请遵循以下Vue最佳实践：
{"\n".join([f"- {practice}" for practice in FrontendPromptOptimizer.FRAMEWORK_BEST_PRACTICES["vue"]])}

{f"\n请考虑以下UI/UX设计因素：\n{"\n".join([f"- {consideration}" for consideration in FrontendPromptOptimizer.UI_UX_CONSIDERATIONS])}" if include_ui else ""}

请提供：
1. 完整的组件实现代码
2. 必要的类型定义（使用TypeScript）
3. 详细的注释说明
4. 使用示例

请确保代码：
- 可直接运行，无需额外修改
- 包含适当的错误处理
- 性能优化得当
- 代码风格一致，可读性高
"""
        
        return prompt
    
    @staticmethod
    def optimize_css_prompt(requirement: str, framework: str = None, 
                          responsive: bool = True, accessibility: bool = True) -> str:
        """
        优化CSS开发的提示词
        
        Args:
            requirement: 原始需求描述
            framework: CSS框架（如Tailwind, Bootstrap等）
            responsive: 是否需要响应式设计
            accessibility: 是否需要考虑可访问性
            
        Returns:
            优化后的提示词
        """
        prompt = f"""
请基于以下需求，编写高质量的CSS样式代码。

原始需求:
{requirement}

{f"CSS框架: {framework}\n" if framework else ""}

请遵循以下CSS最佳实践：
- 使用语义化的CSS选择器
- 避免使用!important和过于具体的选择器
- 合理使用CSS变量管理主题和样式
- 遵循一致的命名规范（如BEM）
- 模块化组织CSS代码
- 减少CSS的重复和冗余
- 优化CSS选择器性能

{f"\n请实现响应式设计，适配以下屏幕尺寸：\n- 移动设备：< 768px\n- 平板：768px - 1024px\n- 桌面：> 1024px" if responsive else ""}

{f"\n请确保样式符合可访问性标准：\n- 颜色对比度符合WCAG AA标准\n- 合理的字体大小和行高\n- 支持键盘导航\n- 可聚焦元素有明确的焦点状态" if accessibility else ""}

请提供：
1. 完整的CSS代码
2. 必要的HTML结构示例
3. 详细的注释说明

请确保代码：
- 可直接使用，无需额外修改
- 性能优化得当
- 代码风格一致，可读性高
"""
        
        return prompt
    
    @staticmethod
    def optimize_javascript_prompt(requirement: str, environment: str = "browser", 
                                complexity: str = "medium", modern: bool = True) -> str:
        """
        优化JavaScript开发的提示词
        
        Args:
            requirement: 原始需求描述
            environment: 运行环境（browser, node, both）
            complexity: 复杂度
            modern: 是否使用现代JavaScript特性
            
        Returns:
            优化后的提示词
        """
        prompt = f"""
请基于以下需求，编写高质量的JavaScript代码。

原始需求:
{requirement}

运行环境: {environment}
{"复杂度: " + complexity + "\n" if complexity else ""}

{f"请使用现代JavaScript特性（ES6+）：\n- 使用let/const而非var\n- 使用箭头函数\n- 使用解构赋值\n- 使用模板字符串\n- 使用Promise和async/await处理异步\n- 使用模块化开发\n- 使用类语法进行面向对象编程\n- 使用Map/Set等现代数据结构" if modern else ""}

请遵循以下JavaScript最佳实践：
- 避免全局变量污染
- 函数职责单一，命名清晰
- 错误处理完善
- 代码组织合理，模块化
- 性能优化得当

{f"\n请考虑浏览器环境的特殊需求：\n- DOM操作高效\n- 事件处理合理\n- 避免内存泄漏\n- 考虑跨浏览器兼容性" if environment in ["browser", "both"] else ""}

{f"\n请考虑Node.js环境的特殊需求：\n- 模块导入导出规范\n- 异步操作处理\n- 错误处理和日志记录\n- 性能和资源管理" if environment in ["node", "both"] else ""}

请提供：
1. 完整的JavaScript代码
2. 详细的注释说明
3. 使用示例

请确保代码：
- 可直接运行，无需额外修改
- 包含适当的错误处理
- 代码风格一致，可读性高
"""
        
        return prompt
    
    @staticmethod
    def create_component_system_prompt(component_type: str, framework: str) -> str:
        """
        创建特定类型组件的系统提示词
        
        Args:
            component_type: 组件类型
            framework: 前端框架
            
        Returns:
            系统提示词
        """
        component_system_prompts = {
            "form": f"""
你是一位专精于{framework}表单组件开发的专家。请根据用户需求，设计并实现高质量的表单组件，确保：

1. 表单验证完善（客户端和服务器端验证考虑）
2. 用户体验良好（即时反馈、错误提示、表单状态管理）
3. 可访问性支持（适当的label、错误提示的ARIA属性等）
4. 代码质量高（组件拆分合理、状态管理清晰、性能优化）

请考虑表单的常见需求：
- 不同类型的输入控件（文本、选择、单选、多选等）
- 表单数据的获取和提交
- 表单状态的管理（加载中、错误、成功等）
- 表单的可重用性和可扩展性
""",
            
            "table": f"""
你是一位专精于{framework}表格组件开发的专家。请根据用户需求，设计并实现高质量的表格组件，确保：

1. 功能完善（排序、筛选、分页、行选择等）
2. 性能优化（大数据量渲染、虚拟滚动等）
3. 用户体验良好（响应式设计、加载状态、空状态等）
4. 代码质量高（组件拆分合理、状态管理清晰）

请考虑表格的常见需求：
- 数据的高效渲染和更新
- 表格的自定义配置（列宽调整、列显示隐藏等）
- 表格的交互（点击行、展开行、编辑行等）
- 表格的可访问性支持
""",
            
            "chart": f"""
你是一位专精于{framework}图表组件开发的专家。请根据用户需求，设计并实现高质量的图表组件，确保：

1. 数据可视化效果好（清晰、直观、美观）
2. 交互体验佳（悬停提示、缩放、钻取等）
3. 性能优化（大数据量渲染、动画效果优化等）
4. 代码质量高（组件拆分合理、状态管理清晰）

请考虑图表的常见需求：
- 不同类型的图表（折线图、柱状图、饼图、散点图等）
- 图表的配置和定制（颜色、标签、图例等）
- 图表的数据更新和动画效果
- 图表的响应式设计
""",
            
            "modal": f"""
你是一位专精于{framework}模态框组件开发的专家。请根据用户需求，设计并实现高质量的模态框组件，确保：

1. 功能完善（显示/隐藏控制、内容自定义等）
2. 用户体验良好（动画效果、背景遮罩、键盘操作等）
3. 可访问性支持（焦点管理、ARIA属性等）
4. 代码质量高（组件拆分合理、状态管理清晰）

请考虑模态框的常见需求：
- 模态框的尺寸和位置控制
- 模态框的内容和交互定制
- 模态框的打开和关闭动画
- 模态框的堆叠和嵌套处理
"""
        }
        
        return component_system_prompts.get(component_type, f"你是一位专精于{framework}组件开发的专家。")
    
    @staticmethod
    def generate_accessibility_checklist() -> List[str]:
        """
        生成可访问性检查清单
        
        Returns:
            可访问性检查项列表
        """
        return [
            "所有图片都有alt属性",
            "所有表单元素都有关联的label标签",
            "颜色对比度符合WCAG AA标准（至少4.5:1）",
            "所有交互元素都可通过键盘访问",
            "焦点状态有明显的视觉指示",
            "使用语义化HTML标签（header, nav, main, section, article, footer等）",
            "正确使用ARIA属性（aria-label, aria-labelledby, aria-describedby等）",
            "页面内容有合理的阅读顺序",
            "避免使用仅依赖颜色传达信息",
            "提供键盘快捷键时，确保可以关闭或重新映射",
            "确保所有交互都有适当的状态反馈",
            "页面标题和文档大纲结构合理"
        ]
    
    @staticmethod
    def generate_performance_checklist() -> List[str]:
        """
        生成性能优化检查清单
        
        Returns:
            性能优化检查项列表
        """
        return FrontendPromptOptimizer.PERFORMANCE_OPTIMIZATIONS
    
    @staticmethod
    def create_frontend_qa_prompt(framework: str, topic: str) -> str:
        """
        创建前端开发问答提示词
        
        Args:
            framework: 前端框架
            topic: 具体主题
            
        Returns:
            优化后的提示词
        """
        prompt = f"""
请作为{framework}专家，详细解答关于{topic}的问题。

请提供：
1. 清晰的概念解释
2. 最佳实践建议
3. 实用的代码示例
4. 常见问题和解决方案

请确保回答：
- 技术准确性高
- 内容实用且可操作
- 代码示例可直接运行
- 语言简洁明了，易于理解

请特别关注{framework}中{topic}的特殊考虑和优化方案。
"""
        
        return prompt
```

### 后端开发领域的提示优化

后端开发也有其特定的需求和最佳实践。以下是一个针对后端开发的提示优化示例：

```python
def optimize_backend_prompt(requirement: str, language: str, framework: str = None, 
                          focus_area: str = None) -> str:
    """
    优化后端开发的提示词
    
    Args:
        requirement: 原始需求描述
        language: 编程语言
        framework: 后端框架
        focus_area: 重点关注领域（如性能、安全、可扩展性等）
        
    Returns:
        优化后的提示词
    """
    # 编程语言特定的最佳实践
    language_best_practices = {
        "python": [
            "遵循PEP 8编码规范",
            "使用类型提示增强代码可读性和可维护性",
            "使用上下文管理器处理资源（with语句）",
            "避免使用可变对象作为默认参数",
            "异常处理完善，避免裸露的except",
            "使用生成器和迭代器处理大数据集",
            "使用装饰器复用代码",
            "使用日志模块记录日志，而非print"
        ],
        "javascript": [
            "使用ES6+特性（箭头函数、解构赋值、模板字符串等）",
            "使用async/await处理异步操作",
            "错误处理完善，使用try/catch和Promise的错误处理",
            "避免回调地狱，使用Promise和async/await",
            "模块导入导出使用ES modules",
            "使用const和let，避免var",
            "使用严格模式（'use strict'）",
            "合理使用闭包和作用域"
        ],
        "java": [
            "遵循Java编码规范（命名规范、缩进等）",
            "使用try-with-resources处理资源",
            "异常处理得当，区分checked和unchecked异常",
            "使用泛型增强类型安全",
            "避免使用静态导入过度",
            "合理使用final关键字",
            "避免创建不必要的对象",
            "使用接口和抽象类进行面向接口编程"
        ],
        "go": [
            "遵循Go的编码风格（使用gofmt格式化）",
            "使用错误返回值而非异常",
            "使用接口定义行为",
            "使用goroutine和channel进行并发编程",
            "避免使用全局变量",
            "使用defer管理资源清理",
            "使用context管理请求范围",
            "合理使用指针"
        ],
        "rust": [
            "遵循Rust的命名规范和编码风格",
            "合理使用所有权、借用和生命周期",
            "错误处理使用Result和Option类型",
            "使用模式匹配简化代码",
            "使用特质(trait)定义共享行为",
            "避免不必要的克隆(clone)",
            "使用unsafe代码块时格外小心",
            "使用宏提高代码复用性"
        ]
    }
    
    # 框架特定的最佳实践
    framework_best_practices = {
        "django": [
            "遵循MTV架构模式",
            "使用Django ORM而非原生SQL",
            "合理使用中间件",
            "使用信号处理解耦代码",
            "正确配置settings模块",
            "使用Django表单进行数据验证",
            "使用Django REST framework构建API",
            "使用缓存机制提高性能"
        ],
        "flask": [
            "使用蓝图(Blueprint)组织路由",
            "合理使用Flask扩展",
            "配置管理使用环境变量或配置文件",
            "使用Flask-SQLAlchemy进行数据库操作",
            "使用Flask-RESTful或Flask-RESTx构建API",
            "合理使用装饰器",
            "错误处理使用错误处理器",
            "测试使用Flask提供的测试客户端"
        ],
        "express": [
            "使用中间件处理跨域、日志、认证等",
            "路由组织合理，使用路由参数",
            "使用环境变量管理配置",
            "合理使用Express的错误处理机制",
            "使用Promises和async/await处理异步操作",
            "使用中间件进行请求验证",
            "合理使用Express生态系统中的模块",
            "性能优化（压缩、缓存等）"
        ],
        "spring": [
            "使用依赖注入管理组件",
            "遵循MVC架构模式",
            "使用Spring Boot简化配置",
            "使用Spring Data访问数据库",
            "使用Spring Security进行认证和授权",
            "使用Spring REST构建RESTful API",
            "合理使用事务管理",
            "使用AOP处理横切关注点"
        ],
        "gin": [
            "使用中间件处理通用功能",
            "路由组织合理，使用路由组",
            "使用Gin的绑定功能进行请求验证",
            "使用Context进行请求和响应处理",
            "错误处理使用统一的错误处理中间件",
            "使用日志中间件记录请求日志",
            "性能优化考虑",
            "测试使用Gin提供的测试工具"
        ]
    }
    
    # 关注领域特定的建议
    focus_area_suggestions = {
        "performance": [
            "数据库查询优化（索引、查询重写等）",
            "缓存策略设计（多级缓存、缓存失效等）",
            "异步处理设计（消息队列、异步任务等）",
            "连接池管理（数据库连接池、HTTP连接池等）",
            "内存使用优化（避免内存泄漏、对象重用等）",
            "并发处理优化（线程池、协程等）",
            "请求限流和熔断设计",
            "资源监控和性能分析"
        ],
        "security": [
            "输入验证和过滤",
            "认证和授权机制",
            "密码安全存储（使用bcrypt等算法）",
            "防止常见攻击（SQL注入、XSS、CSRF等）",
            "HTTPS配置和证书管理",
            "敏感信息保护（环境变量、加密等）",
            "日志脱敏",
            "依赖安全管理（定期更新、漏洞扫描等）"
        ],
        "scalability": [
            "水平扩展设计",
            "无状态设计",
            "数据分片和分区策略",
            "服务拆分和微服务架构考虑",
            "负载均衡策略",
            "分布式一致性方案",
            "资源隔离设计",
            "监控和告警系统设计"
        ],
        "maintainability": [
            "代码组织和模块化",
            "清晰的命名和注释",
            "全面的日志记录",
            "完整的单元测试和集成测试",
            "API文档（如Swagger/OpenAPI）",
            "配置外部化",
            "错误处理和恢复机制",
            "版本控制和API版本管理"
        ]
    }
    
    prompt = f"""
请基于以下需求，使用{language}{f"和{framework}" if framework else ""}实现一个高质量的后端功能。

原始需求:
{requirement}

请遵循以下{language}最佳实践：
{"\n".join([f"- {practice}" for practice in language_best_practices.get(language, [])])}

{f"\n请遵循以下{framework}最佳实践：\n{"\n".join([f"- {practice}" for practice in framework_best_practices.get(framework, [])])}" if framework else ""}

{f"\n请特别关注{focus_area}方面：\n{"\n".join([f"- {suggestion}" for suggestion in focus_area_suggestions.get(focus_area, [])])}" if focus_area else ""}

请提供：
1. 完整的代码实现
2. 必要的配置说明
3. 详细的注释
4. 使用示例

请确保代码：
- 可直接运行，无需额外修改
-