# 第7期 提示工程的基本原则与模式

欢迎回到AI编程深度专研系列教程！在前面的内容中，我们已经了解了AI编程的基本概念、大型语言模型的工作原理以及训练过程。从本期开始，我们将进入教程的第三章：高级提示工程。这是与AI编程助手有效协作的核心技能。本期我们将探讨提示工程的基本原则与模式，为后续更高级的技巧奠定基础。

## 3.1.1 提示工程的核心原则

### 3.1.1.1 清晰性与具体性

清晰性和具体性是有效提示的首要原则。AI模型只能基于你提供的信息进行推理，因此你的指令越清晰明确，得到的结果就越符合预期。

**实践建议：**
- **明确任务目标**：清晰说明你想要完成的具体任务
- **提供具体示例**：通过示例展示期望的输出格式和内容
- **避免模糊表述**：避免使用模糊不清的词语，如"大概"、"可能"、"好像"
- **量化要求**：尽可能使用数字和具体指标描述要求（如代码行数、性能指标等）

**示例对比：**

模糊提示：
```
写一个排序算法，要高效一点。
```

清晰提示：
```
用Python实现一个快速排序算法，要求：
1. 函数名为quick_sort，接收一个整数列表作为参数
2. 返回排序后的新列表，不修改原列表
3. 包含适当的注释解释算法步骤
4. 时间复杂度为O(n log n)
```

### 3.1.1.2 指令与上下文平衡

有效的提示需要平衡指令部分和上下文部分，确保模型既有明确的执行方向，又有足够的相关信息。

**实践建议：**
- **指令前置**：将最重要的指令放在提示的开头
- **上下文结构化**：使用分隔符（如```、---等）明确区分指令和上下文
- **上下文相关性**：只提供与任务相关的上下文信息
- **上下文完整性**：确保提供的上下文足够完整，避免模型猜测缺失信息

**示例结构：**
```
任务：编写一个函数计算斐波那契数列的第n项

要求：
- 函数名为fibonacci
- 输入为非负整数n
- 使用递归实现
- 包含基本的参数验证

示例：
fibonacci(0) 应返回 0
fibonacci(1) 应返回 1
fibonacci(10) 应返回 55
```

### 3.1.1.3 格式控制与输出一致性

控制输出格式可以帮助你获得结构化、一致的结果，便于后续处理或使用。

**实践建议：**
- **指定输出格式**：明确要求特定的输出格式（如JSON、XML、代码块等）
- **提供格式模板**：给出期望输出的模板或结构
- **使用标记符**：使用特殊标记符（如```code、<json>等）限定输出区域
- **设置输出长度限制**：必要时指定输出的大致长度或范围

**格式控制示例：**
```
请分析以下Python代码中的性能问题，并以JSON格式输出分析结果：

```python
def calculate_sum(numbers):
    total = 0
    for i in range(len(numbers)):
        total += numbers[i]
    return total
```

输出格式：
{
  "issues": [
    {
      "type": "性能问题类型",
      "description": "问题描述",
      "line": 问题所在行,
      "suggestion": "改进建议"
    }
  ],
  "optimized_code": "优化后的代码"
}
```

### 3.1.1.4 模型能力边界意识

了解并尊重模型的能力边界是提示工程的重要原则。不同模型在不同领域有不同的专长和局限。

**实践建议：**
- **了解模型知识截止时间**：模型只知道训练数据截止前的信息
- **避免要求不可能完成的任务**：如需要实时数据、超长上下文理解等
- **分解复杂任务**：将复杂任务拆分为模型能够处理的子任务
- **验证关键信息**：对于重要信息，要求模型提供验证或来源

**代码相关边界意识示例：**
```
请编写一个Python函数实现快速排序算法。注意：
- 请专注于算法的正确性和清晰性
- 无需实现过于复杂的优化（如三路快速排序）
- 如果遇到不明确的要求，请提供合理的默认实现
```

## 3.1.2 基础提示模式

### 3.1.2.1 指令式提示

指令式提示是最基础和直接的提示模式，通过明确的指令告诉模型要做什么。

**结构特点：**
- 以动词开头的明确指令
- 简洁明了，直接表达需求
- 适用于简单明确的任务

**示例：**
```
编写一个Python函数，计算两个向量的点积。

分析以下代码中的错误并修复。

将以下JavaScript代码翻译成Python。
```

### 3.1.2.2 对话式提示

对话式提示模拟自然对话的形式，通过多轮交互逐步引导模型完成复杂任务。

**结构特点：**
- 使用角色标识区分用户和助手
- 多轮交互，逐步深入任务
- 可以基于前一轮的输出继续追问或纠正

**示例：**
```
用户：我需要写一个函数来验证电子邮件地址的格式是否正确。
助手：我可以帮你实现这个功能。你想要用什么编程语言？有什么特殊的验证要求吗？
用户：用JavaScript实现，需要支持常见的邮箱域名，并且要考虑国际化邮箱地址。
助手：好的，我会为你编写一个符合要求的JavaScript邮箱验证函数。
```

### 3.1.2.3 示例式提示

示例式提示通过提供输入-输出示例来引导模型理解任务要求和期望输出格式。

**结构特点：**
- 包含一个或多个示例（输入+输出对）
- 示例应具有代表性，涵盖典型情况
- 可以混合使用指令和示例

**示例：**
```
请根据输入的代码片段生成对应的函数注释。示例如下：

输入：
```python
def add(a, b):
    return a + b
```

输出：
```python
"""
计算两个数的和

参数:
    a: 第一个数
    b: 第二个数

返回:
    两个数的和
"""
def add(a, b):
    return a + b
```

现在请处理以下代码：
```python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n-1)
```
```

### 3.1.2.4 任务分解式提示

任务分解式提示将复杂任务分解为一系列更简单的子任务，帮助模型逐步解决问题。

**结构特点：**
- 将主任务拆分为多个步骤
- 为每个步骤提供明确的指令
- 通常按照逻辑顺序排列子任务

**示例：**
```
让我们逐步解决这个编程问题：

步骤1：分析问题
请解释以下问题的需求和约束：给定一个字符串列表，编写一个函数，返回包含至少两个重复字符的字符串数量。

步骤2：设计算法
根据问题分析，设计一个算法来解决这个问题。

步骤3：代码实现
用Python实现上述算法，要求代码清晰易读。

步骤4：测试验证
为你的实现编写测试用例，确保覆盖各种情况。
```

## 3.1.3 代码生成的特殊提示技巧

### 3.1.3.1 环境与依赖说明

在代码生成任务中，明确说明编程环境、语言版本和依赖库是获得正确代码的关键。

**实践建议：**
- **指定编程语言版本**：如Python 3.9、JavaScript ES6等
- **列出可用的库和版本**：如使用NumPy 1.21.0、React 18等
- **说明运行环境限制**：如浏览器端、Node.js环境、特定框架等
- **指定编译器/解释器要求**：如有特殊编译选项或配置

**示例：**
```
请使用Python 3.8及以上版本编写一个函数，该函数使用pandas库（版本1.3.0+）处理CSV文件。请确保代码与以下环境兼容：
- Python 3.8
- pandas 1.3.0
- numpy 1.20.0

不要使用任何其他第三方库。
```

### 3.1.3.2 代码质量与风格要求

指定代码质量和风格要求有助于获得符合团队标准和最佳实践的代码。

**实践建议：**
- **指定编码规范**：如PEP 8（Python）、ESLint规则（JavaScript）等
- **要求注释和文档**：如函数文档字符串、关键步骤注释等
- **指定命名约定**：如驼峰命名法、下划线分隔法等
- **设置性能要求**：如时间复杂度、空间复杂度限制

**示例：**
```
请用Java实现一个二分查找算法，要求：
1. 遵循Java编码规范（驼峰命名法）
2. 包含详细的方法文档注释
3. 处理边界情况和异常
4. 时间复杂度为O(log n)
5. 添加必要的单元测试
```

### 3.1.3.3 功能约束与边界条件

明确功能约束和边界条件有助于获得健壮且正确的代码。

**实践建议：**
- **列出输入参数的约束条件**：如类型、范围、格式等
- **说明特殊情况的处理方式**：如空输入、边界值等
- **指定错误处理策略**：如抛出异常、返回默认值等
- **定义性能边界**：如最大输入大小、响应时间要求等

**示例：**
```
请实现一个函数，将字符串转换为整数。要求：
1. 函数应处理负数和正数
2. 忽略前导空格
3. 处理溢出情况（对于32位整数，返回Integer.MAX_VALUE或Integer.MIN_VALUE）
4. 对于无效输入，返回0
5. 不要使用内置的parseInt或类似函数
```

### 3.1.3.4 测试与验证要求

在提示中包含测试和验证要求，有助于确保生成的代码具有良好的质量和可靠性。

**实践建议：**
- **要求提供单元测试**：如测试函数、测试用例等
- **指定测试覆盖率要求**：如关键路径、边界条件等
- **要求性能测试**：对于性能敏感的代码
- **提供验证方法**：如如何验证代码的正确性

**示例：**
```
请实现一个高效的排序算法，要求：
1. 用C++编写
2. 针对大型数据集（百万级元素）进行优化
3. 提供完整的单元测试，覆盖：
   - 空数组
   - 已排序数组
   - 逆序数组
   - 包含重复元素的数组
   - 大规模随机数组
4. 添加性能测试代码，比较你的实现与标准库排序函数的性能
```

## 3.1.4 不同编程任务的提示策略

### 3.1.4.1 代码生成任务

针对代码生成任务的专门提示策略：

**实践建议：**
- **详细的功能描述**：清晰说明期望的功能和行为
- **输入输出示例**：提供具体的输入和期望输出示例
- **逐步引导**：对于复杂功能，分步骤引导生成过程
- **强调代码可读性**：要求适当的注释和清晰的结构

**示例：**
```
请编写一个Python函数，用于检测字符串是否为有效的IPv4地址。

函数要求：
- 函数名：is_valid_ipv4
- 参数：一个字符串
- 返回值：布尔值，表示是否为有效的IPv4地址

有效的IPv4地址规则：
1. 由四个十进制数组成，用点分隔
2. 每个数的范围是0-255
3. 不能有前导零（除非是单个零）

示例：
- is_valid_ipv4("192.168.1.1") 应返回 True
- is_valid_ipv4("192.168.1.01") 应返回 False
- is_valid_ipv4("192.168.1") 应返回 False
- is_valid_ipv4("192.168.1.256") 应返回 False
```

### 3.1.4.2 代码解释任务

针对代码解释任务的专门提示策略：

**实践建议：**
- **明确解释级别**：如高级概述、逐行解释、技术细节等
- **重点关注**：指定需要特别解释的部分或概念
- **输出格式**：如使用段落、列表、流程图等
- **要求知识连接**：将代码与更广泛的概念或模式联系起来

**示例：**
```
请详细解释以下Python代码的工作原理，重点说明装饰器的作用机制：

```python
import functools

def memoize(func):
    cache = {}
    @functools.wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

@memoize
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

请按照以下结构解释：
1. 代码的整体功能
2. memoize装饰器的工作原理（包括闭包概念）
3. functools.wraps的作用
4. 装饰器如何优化fibonacci函数的性能
5. 这种优化技术的名称和适用场景
```

### 3.1.4.3 代码优化任务

针对代码优化任务的专门提示策略：

**实践建议：**
- **明确优化目标**：如性能、内存使用、可读性等
- **提供上下文**：代码的使用场景和约束条件
- **要求分析与改进**：先分析问题，再提供改进方案
- **要求比较**：优化前后的对比数据或分析

**示例：**
```
请分析并优化以下Python代码，目标是提高性能：

```python
def find_duplicates(numbers):
    duplicates = []
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if numbers[i] == numbers[j] and numbers[i] not in duplicates:
                duplicates.append(numbers[i])
    return duplicates
```

请：
1. 分析当前实现的时间复杂度和空间复杂度
2. 指出性能瓶颈
3. 提供至少一种优化实现
4. 分析优化后的时间复杂度和空间复杂度
5. 解释优化思路
```

### 3.1.4.4 代码翻译任务

针对代码翻译任务的专门提示策略：

**实践建议：**
- **明确目标语言和版本**：具体的编程语言和版本
- **强调语义等价**：保持功能和行为的一致性
- **适应目标语言特性**：利用目标语言的特性和最佳实践
- **注意语言差异**：处理不同语言之间的语法和语义差异

**示例：**
```
请将以下Java代码翻译为Python 3.8：

```java
public class StringUtils {
    public static String reverseWords(String s) {
        String[] words = s.trim().split("\\s+");
        StringBuilder reversed = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            reversed.append(words[i]);
            if (i > 0) {
                reversed.append(" ");
            }
        }
        return reversed.toString();
    }
}
```

要求：
1. 保持功能完全一致
2. 遵循Python的编码规范和最佳实践
3. 使用Python特有的功能（如列表推导式、切片等）优化代码
4. 添加适当的函数文档字符串
```

## 3.1.5 实践指南：构建有效提示的步骤

### 3.1.5.1 任务分析与目标明确化

构建有效提示的第一步是深入分析任务并明确目标。

**实践步骤：**
1. **明确任务类型**：确定是代码生成、解释、优化还是翻译任务
2. **定义具体目标**：详细说明你期望实现的具体目标
3. **确定关键要求**：识别任务的关键约束和要求
4. **考虑输出用途**：思考生成结果将如何使用，这会影响提示设计

**示例思考过程：**
"我需要一个函数来处理用户输入的数据验证。这是一个代码生成任务。我需要具体说明验证规则、错误处理方式、返回值格式，并且要考虑它将在Web表单中使用，所以需要支持不同类型的输入验证。"

### 3.1.5.2 提示结构设计

根据任务分析，设计一个清晰、结构化的提示。

**实践步骤：**
1. **开头点明主题**：直接说明任务的核心内容
2. **详细描述要求**：使用列表或分点说明具体要求
3. **提供必要示例**：包含输入-输出示例
4. **指定输出格式**：明确期望的输出格式
5. **使用分隔符**：使用分隔符区分不同部分

**提示结构模板：**
```
任务: [简要说明任务]

详细要求:
1. [要求1]
2. [要求2]
3. [要求3]

示例:
输入: [示例输入]
输出: [示例输出]

[相关上下文或额外说明]

输出格式: [期望的输出格式]
```

### 3.1.5.3 提示测试与迭代优化

编写提示后，进行测试并根据结果迭代优化。

**实践步骤：**
1. **初始测试**：使用初始提示进行测试
2. **分析结果**：评估生成结果与期望的差距
3. **针对性调整**：根据分析结果调整提示的具体部分
4. **多次迭代**：重复测试和调整，直到获得满意结果
5. **记录优化过程**：记录提示的变化和对应的效果变化

**常见调整方向：**
- 增加或减少具体细节
- 调整提示的结构和顺序
- 提供更多或更精确的示例
- 明确或放松某些约束条件
- 调整语言风格和指令的明确程度

### 3.1.5.4 提示库建设

随着经验积累，建立个人或团队的提示库，提高工作效率。

**实践建议：**
- **分类整理**：按任务类型、编程语言、复杂度等分类
- **记录效果**：为每个提示记录其效果和适用场景
- **版本管理**：跟踪提示的改进和演变
- **共享协作**：团队成员共同维护和改进提示库
- **定期回顾**：定期回顾和更新提示，适应模型的发展

**提示库示例结构：**
```
提示库/
├── 代码生成/
│   ├── 函数实现/
│   │   ├── 数据处理函数.md
│   │   ├── 算法实现.md
│   │   └── ...
│   ├── 类设计/
│   └── ...
├── 代码解释/
│   ├── 算法解释.md
│   ├── 设计模式解释.md
│   └── ...
├── 代码优化/
└── 代码翻译/
```

## 总结

本期我们深入探讨了提示工程的基本原则与模式，包括核心原则（清晰性与具体性、指令与上下文平衡、格式控制与输出一致性、模型能力边界意识），基础提示模式（指令式、对话式、示例式、任务分解式），代码生成的特殊提示技巧，以及针对不同编程任务的提示策略。最后，我们提供了构建有效提示的实践步骤指南。

提示工程是与AI编程助手协作的关键技能，通过精心设计的提示，我们可以更有效地引导模型生成高质量、符合需求的代码。掌握这些基本原则和模式，将为后续学习更高级的提示工程技术奠定坚实基础。

在下一期中，我们将继续深入第三章内容，探讨高级提示工程技术中的提示词优化与指令工程，学习如何通过更精细的提示词设计来获得更精确的代码生成结果。敬请期待！

## 思考与练习

1. 分析你过去使用AI编程助手时遇到的问题，思考是否可以通过改进提示来解决。
2. 选择一个简单的编程任务，设计至少三种不同的提示方式，比较它们的效果。
3. 为特定的代码生成任务构建一个结构化的提示，包括所有必要的组件。
4. 实践构建个人提示库，从简单的任务开始积累有效提示。

---

*本教程将持续更新，跟进AI编程领域的最新发展与最佳实践。*