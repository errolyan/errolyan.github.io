# 第176期 Claude Code 性能强劲——6个月重构30w行代码（经验与教训贴）


## 补充说明1
看到很多人在问代码仓库的链接，我会尽量在未来几天内搭建好并分享出来。目前这些内容都属于工作项目的一部分，所以我需要花些时间将相关内容复制到一个全新的项目中，并删除所有标识性信息。链接发布后我会在这里更新，大家也可以关注我，我会在个人主页发布相关动态，方便大家及时收到通知。感谢大家的友好评论，我很乐意把这些信息分享给更多人——毕竟在日常生活中，我很少有这样的分享机会。

## 补充说明2（最终版？）
我还是下定决心，花了一个下午为大家搭建好了GitHub代码仓库。我刚刚发布了一篇包含更多补充信息的帖子，大家可以点击[此处](https://example.com)查看，也可以直接访问代码源地址：

🎯 代码仓库：https://github.com/diet103/claude-code-infrastructure-showcase

## 免责声明
大约6个月前，我曾发布过一篇帖子，分享了使用Claude Code一周后的高强度使用体验。如今，我已经高强度使用这款工具近6个月，想再和大家分享一些技巧、窍门，以及一些随心所想的内容。可能这次内容有点多，大家可以做好准备——泡杯咖啡、坐在马桶上，或者用你平时刷Reddit的姿势来阅读都可以。

首先必须声明：本文分享的所有内容，都只是我目前正在使用且感觉效果不错的配置方案，绝非“圣经”或唯一正确的方法。我希望这些内容能给大家带来启发，帮助大家优化AI智能体编码（AI agentic coding）的配置和工作流程。我只是个普通人，这些也只是我的个人观点而已。

另外，我使用的是20x Max套餐，所以大家的使用体验可能会有所不同。如果你在寻找“氛围感编码”技巧，那本文可能不适合你。如果你想充分发挥Claude Code（以下简称CC）的性能，就需要和它协同工作：共同规划、审核代码、反复迭代、探索不同解决方案等。

## 内容概览
在6个月的时间里，我不断挑战Claude Code的性能极限（独自重写了30万行代码），最终搭建出了一套高效系统，核心包括以下4个部分：
- 可在需要时自动激活的技能（Skills）
- 能防止Claude“偏离目标”的开发文档（Dev Docs）工作流程
- 结合PM2与钩子（Hooks），实现“零遗漏错误”
- 一支用于代码审核、测试和规划的专业智能体（Agents）团队

下面我们来详细介绍。

## 背景介绍
我是一名软件工程师，过去7年左右一直在从事生产环境Web应用的开发工作，并且完全拥抱了人工智能的浪潮。我并不担心AI会很快取代我的工作——因为它只是我提升工作能力的工具。借助AI，我开发了许多新功能，还利用Claude和GPT-5 Thinking整理出各种新方案演示文稿，将新的AI系统集成到我们的生产应用中。要是在工作流程中引入AI之前，我根本没时间去考虑这些项目。也正因为如此，我的工作稳定性有了很大保障，还成了公司里的“AI专家”——毕竟其他人在AI与日常工作融合方面，大概还落后我一年左右。

凭借这份新建立的信心，我提出要对公司内部使用的一款Web应用进行大规模重新设计和重构。这款应用最初是由一名大学生开发的，后来从我的一个实习项目（约7年前创建，4年前分支出来）中分支而来，基础非常薄弱。现在想来，这个决定可能有些过于激进——为了说服项目相关方，我承诺在几个月内独自完成这个规模不小的项目（约10万行代码）的自上而下全面重构。我知道，即便有CC的帮助，我也需要加班才能完成，但我内心清楚，这个项目最终一定会大获成功：它能自动化多个手动流程，为公司很多人节省大量时间。

如今6个月过去了……说实话，我当初真不该答应那个时间节点。为了完成这个项目，我不仅挑战了Claude的性能极限，也快把自己逼到了精神崩溃的边缘。我彻底舍弃了旧的前端架构——因为所有组件都已严重过时，我想尝试最新的技术栈。具体来说，技术栈升级包括：React 16（JavaScript）→ React 19（TypeScript）、React Query v2 → TanStack Query v5、React Router v4（哈希路由）→ TanStack Router（基于文件的路由）、Material UI v4 → MUI v7，且所有升级都严格遵循最佳实践。现在这个项目的代码量已达到30万-40万行，而我感觉自己的预期寿命都缩短了5年。不过好在项目终于可以进入测试阶段了，我对最终结果也非常满意。

这个项目曾经面临诸多问题：难以解决的技术债务、零测试覆盖率、极差的开发体验（测试过程简直是噩梦），还有各种混乱的代码逻辑。现在我已经解决了所有这些问题：实现了不错的测试覆盖率、将技术债务控制在可管理范围内、开发了一个命令行工具用于生成测试数据，还添加了开发模式以便在前端测试不同功能。在这个过程中，我也逐渐摸清了CC的能力边界，知道该对它抱有怎样的预期。

## 关于质量与一致性的说明
我注意到论坛和讨论中经常出现一个话题：很多人对使用限制感到不满，还担心工具的输出质量会随着时间下降。在此我想明确一点：我并不是要否定这些人的体验，也不是说“问题出在你们使用方法不对”。每个人的使用场景和背景都不同，合理的担忧理应得到重视。

但与此同时，我也想分享一下我自己的使用体验。在我看来，过去几个月里CC的输出质量其实有了显著提升，我认为这很大程度上要归功于我不断优化的工作流程。我希望大家能从我的系统中获得一些启发，并将其融入自己的CC工作流程中，让CC有更好的机会输出令你满意的高质量结果。

不过说实话，Claude有时确实会“跑偏”，输出质量欠佳的代码。这背后有多种原因：首先，AI模型具有随机性，即便输入相同，输出结果也可能差异很大。有时只是运气不好，即便你没有任何操作失误，也可能得到质量低下的输出。其次，提示词（Prompt）的结构也会影响结果——哪怕只是措辞上的细微差别，都可能导致输出结果截然不同，因为模型对文字的理解非常字面化。如果你的表述有误或模糊不清，最终结果可能会差很多。

## 有时需要人工介入
AI确实很强大，但它并非“魔法”。在某些问题上，人类的模式识别能力和直觉还是更具优势。如果你看着Claude花了30分钟都解决不了一个问题，而你自己2分钟就能搞定，那就别犹豫，自己动手解决吧——这没什么好难为情的。这就像教别人骑自行车，有时你需要扶一下车把，再放手让对方自己尝试。

这种情况在逻辑谜题或需要现实常识的问题上尤为明显。AI确实能暴力破解很多问题，但有些时候人类的理解速度就是更快。别因为固执，或是抱着“AI就该解决所有问题”的错误想法而浪费时间。该介入时就介入，解决问题后继续推进工作即可。

我自己也有过很多糟糕的提示词编写经历——通常是在一天快结束时，我变得越来越懒，在编写提示词时没有投入足够精力，结果也显而易见。所以下次当你觉得“最近输出质量变差，可能是Anthropic暗中限制了Claude性能”时，不妨停下来反思一下自己编写提示词的方式。

要经常重新编写提示词。你可以按两次ESC键调出之前的提示词，然后选择一个作为基础进行调整。有意思的是，当你知道自己不想要什么结果时，即便是相同的需求，重新编写的提示词也常常能带来好得多的输出。总而言之，输出质量下降可能有多种原因，自我反思并思考如何为Claude提供更好的条件以获得理想输出，是很有必要的。

就像某个智者可能说过的那样：“不要问Claude能为你做什么，要问你能为Claude提供什么上下文”——某位智者

好了，我的“说教”就到这里，接下来我们进入正题。

## 我的工作系统
过去6个月里，我对与CC相关的工作流程做了很多调整，效果在我看来非常不错。

### 技能自动激活系统（颠覆性改进！）
这个系统值得单独拿出来讲——因为它彻底改变了我使用Claude Code的方式。

#### 遇到的问题
Anthropic推出“技能（Skills）”功能时，我特别兴奋：“这看起来太棒了！”——有了这些可移植、可复用的指导原则，Claude就能在我庞大的代码库中保持一致性，这想法简直完美。我花了大量时间和Claude一起编写了全面的技能文档，涵盖前端开发、后端开发、数据库操作、工作流程管理等领域，其中包含数千行最佳实践、模式示例和案例。

但结果却不尽如人意：Claude根本不用这些技能文档。我甚至用了技能描述中完全一样的关键词，没用；我处理本应触发技能的文件，还是没用。这太让人沮丧了——我明明看到了这个功能的潜力，可它却像昂贵的装饰品一样，毫无用处。

#### 顿悟时刻
就在这时，我想到了“钩子（Hooks）”。既然Claude不会自动使用技能，那我能不能搭建一个系统，让它在做任何操作前都必须检查相关技能呢？

于是我深入研究了Claude Code的钩子系统，用TypeScript钩子搭建了一个多层级的自动激活架构——而且它真的管用！

#### 工作原理
我创建了两个核心钩子：

1. UserPromptSubmit钩子（在Claude看到你的消息前运行）
   - 分析提示词中的关键词和意图模式
   - 判断可能相关的技能
   - 在Claude的上下文中注入格式化的提醒
   - 比如当我问“布局系统如何工作？”时，Claude在看到我的问题前，会先看到一条醒目的提示：“🎯 技能激活检查——请使用project-catalog-developer技能”（注：project catalog是我前端中一个基于复杂数据网格的功能）

2. Stop Event钩子（在Claude回复完成后运行）
   - 分析哪些文件被修改过
   - 检查高风险代码模式（try-catch块、数据库操作、异步函数等）
   - 显示温和的自检提醒，比如“是否添加了错误处理？Prisma操作是否使用了仓库模式？”
   - 这种提醒不会阻碍操作，只会让Claude保持警惕，不会让人觉得厌烦

#### skill-rules.json配置文件
我创建了一个中央配置文件，为每个技能定义以下内容：
- 关键词：明确的主题匹配（如“layout”“workflow”“database”）
- 意图模式：用于捕捉操作的正则表达式（如“(create|add).*?(feature|route)”）
- 文件路径触发条件：根据正在编辑的文件激活技能
- 内容触发条件：如果文件包含特定模式（如Prisma导入语句、控制器代码等），则激活技能

配置示例片段如下：
```json
{
  "backend-dev-guidelines": {
    "type": "domain",
    "enforcement": "suggest",
    "priority": "high",
    "promptTriggers": {
      "keywords": ["backend", "controller", "service", "API", "endpoint"],
      "intentPatterns": [
        "(create|add).*?(route|endpoint|controller)",
        "(how to|best practice).*?(backend|API)"
      ]
    },
    "fileTriggers": {
      "pathPatterns": ["backend/src/**/*.ts"],
      "contentPatterns": ["router\\.", "export.*Controller"]
    }
  }
}
```

#### 实施效果
现在当我处理后端代码时，Claude会自动完成以下操作：
- 在阅读我的提示词前看到技能建议
- 加载相关的指导原则
- 真正始终如一地遵循代码模式
- 在最后通过温和的提醒进行自检

前后对比简直天差地别：代码不再不一致，不会再出现“等等，Claude怎么又用了旧模式”的情况，也不用每次都手动提醒它去查看指导原则了。

#### 践行Anthropic最佳实践（走了些弯路）
在实现技能自动激活后，我进一步研究了Anthropic官方的最佳实践文档，结果发现自己之前的做法有误——官方建议将主要的SKILL.md文件控制在500行以内，并使用资源文件实现“渐进式披露”。

我之前的做法确实有问题：我的frontend-dev-guidelines技能文档有1500多行，还有其他几个技能文档也超过了1000行。这种庞大的单文件完全违背了技能功能的初衷——毕竟技能本应“只加载需要的内容”。

于是我重新调整了所有技能文档的结构：
- frontend-dev-guidelines：398行的主文件 + 10个资源文件
- backend-dev-guidelines：304行的主文件 + 11个资源文件

现在Claude会先加载轻量化的主文件，只有在真正需要时才会加载详细的资源文件。对于大多数查询，令牌（Token）效率提升了40%-60%。

#### 我创建的技能
以下是我目前正在使用的技能列表，分为“指导原则与最佳实践”和“特定领域”两类：

**指导原则与最佳实践类**
- backend-dev-guidelines：涵盖路由→控制器→服务→仓库（Routes → Controllers → Services → Repositories）的全流程规范
- frontend-dev-guidelines：包含React 19、MUI v7、TanStack Query/Router的代码模式
- skill-developer：用于创建更多技能的“元技能”

**特定领域类**
- workflow-developer：复杂工作流引擎的代码模式
- notification-developer：电子邮件/通知系统的开发规范
- database-verification：防止列名错误（这是一个“护栏”技能，能实际阻止错误编辑！）
- project-catalog-developer：DataGrid布局系统的开发指南

所有这些技能都会根据我正在处理的工作自动激活，就像有一位记得所有代码模式的高级开发人员在旁边监督Claude一样。

#### 该系统的重要性
在使用“技能+钩子”组合之前，我面临很多问题：
- 即便我写了新的代码模式文档，Claude还是会用旧模式
- 每次都要手动提醒Claude去查看BEST_PRACTICES.md
- 在超过30万行代码的代码库中，代码风格不一致
- 要花大量时间修正Claude对代码规范的“创造性解读”

而使用“技能+钩子”之后，情况完全不同：
- 代码模式会自动保持一致
- Claude在我看到代码前就会自我修正
- 可以放心，代码会遵循指导原则
- 在代码审核和修正上花费的时间大幅减少

如果你正在处理一个有既定代码模式的大型代码库，我强烈推荐你搭建这样的系统。虽然初始设置需要几天时间才能调整到位，但它带来的回报绝对是投入的十倍以上。

### CLAUDE.md与文档的演变
6个月前我发布的帖子中，有一部分提到“规则是你最好的朋友”，现在我依然认同这一点。但当时我的CLAUDE.md文件内容越来越庞杂，承担了太多功能；另外还有一个1400多行的庞大BEST_PRACTICES.md文件，Claude有时会看，有时则完全忽略。

于是我花了一个下午和Claude一起，将所有文档整合并重构为一套新系统，主要调整如下：

#### 迁移到技能中的内容
以前BEST_PRACTICES.md包含以下内容，现在这些都已迁移到技能文档中，并且通过自动激活钩子确保Claude会实际使用它们——再也不用指望Claude“记得”去查看BEST_PRACTICES.md了：
- TypeScript标准
- React模式（钩子、组件、 suspense 等）
- 后端API模式（路由、控制器、服务等）
- 错误处理（Sentry集成）
- 数据库模式（Prisma使用规范）
- 测试指导原则
- 性能优化方法

#### 保留在CLAUDE.md中的内容
现在的CLAUDE.md专注于“项目特定信息”，篇幅仅约200行，主要包括：
- 快速命令（如pnpm pm2:start、pnpm build等）
- 服务特定配置
- 任务管理工作流程（开发文档系统）
- 已认证路由的测试方法
- 工作流 dry-run 模式
- 浏览器工具配置

#### 新的文档结构
**根目录下的CLAUDE.md（100行）**
- 核心通用规则
- 指向各仓库特定claude.md文件的链接
- 指向技能文档的链接（用于获取详细指导原则）

**每个仓库下的claude.md（50-100行）**
- 快速开始部分，包含以下文档的链接：
  - PROJECT_KNOWLEDGE.md：架构与集成相关内容
  - TROUBLESHOOTING.md：常见问题解决方案
  - 自动生成的API文档
- 仓库特定的注意事项和命令

这套结构的巧妙之处在于：技能文档负责“如何编写代码”的指导原则，CLAUDE.md负责“这个特定项目如何运作”的信息——通过职责分离实现了高效管理。

### 开发文档系统
除了技能系统外，这个开发文档系统对我从CC中获得理想结果的影响最大。Claude就像一个极其自信但健忘的初级开发人员，很容易忘记自己正在做什么——而这个系统正是为解决这个问题设计的。

以下是我CLAUDE.md中关于开发文档系统的内容：

#### 大型任务启动流程
当退出计划模式且计划已通过时，需执行以下步骤：
1. **创建任务目录**：
   ```bash
   mkdir -p ~/git/project/dev/active/[任务名称]/
   ```
2. **创建文档**：
   - `[任务名称]-plan.md`：已通过的计划
   - `[任务名称]-context.md`：关键文件、决策记录
   - `[任务名称]-tasks.md`：工作清单
3. **定期更新**：完成任务后立即标记，确保及时性

#### 任务继续流程
- 检查`/dev/active/`目录，确认是否存在现有任务文档
- 继续工作前阅读上述三个文档
- 更新“最后更新时间”戳

每个功能或大型任务都必须创建这些文档。在使用这个系统之前，我经常遇到这样的情况：30分钟前明明和Claude规划好了要做什么，结果因为偏离方向，最后完全没有按计划执行。

#### 我的规划流程
我的工作流程从规划开始——规划至关重要。如果你在让Claude实现某个功能前，连最基本的计划模式都不用，那很可能会遇到麻烦。这就像请建筑工人来家里扩建房屋，却不先让他们画设计图一样。

当我开始规划一个功能时，会先进入计划模式（尽管最终我会让Claude把计划写在markdown文件中）。我不确定进入计划模式是否绝对必要，但对我来说，计划模式能让Claude更好地研究代码库、获取正确的上下文，从而制定出更完善的计划。

我创建了一个名为strategic-plan-architect的子智能体，它在规划方面非常出色，能完成以下工作：
- 高效收集上下文信息
- 分析项目结构
- 制定全面的结构化计划，包含执行摘要、阶段划分、任务列表、风险评估、成功指标和时间线
- 自动生成三个文件：计划文档、上下文文档和任务清单

但这个智能体有个缺点：无法查看它的输出内容；更麻烦的是，如果拒绝它的计划，它不会继续调整，而是直接停止运行。因此，我在CC主界面上创建了一个自定义斜杠命令（/dev-docs），使用相同的提示词来规避这个问题。

当Claude生成计划后，我会花时间仔细审核——这一步非常重要。花时间理解计划内容，你会惊讶地发现，Claude经常会犯一些低级错误，或是误解需求中非常关键的部分。

通常，退出计划模式后，上下文剩余量会在15%或以下，但这没关系——因为我们会把重新开始所需的所有信息都整理到开发文档中。Claude通常会迫不及待地开始编写代码，这时我会立即按ESC键中断它，然后运行/dev-docs斜杠命令。该命令会根据已通过的计划创建上述三个文档，如果上下文足够，还会进一步研究以补充遗漏的信息。

完成这些步骤后，即便遇到自动压缩上下文的情况，Claude也能完整实现功能，不会偏离方向。我只需要偶尔提醒Claude更新任务清单和上下文文档，补充相关信息即可。当当前会话的上下文不足时，我会运行/update-dev-docs斜杠命令——Claude会记录相关上下文（包括下一步计划）、标记已完成的任务或添加新任务，之后我再压缩对话。在新会话中，只需输入“继续”即可恢复工作。

在功能实现过程中，根据功能或任务的规模，我会明确要求Claude一次只实现一两个部分。这样我就能在每完成一组任务后审核代码；同时，我还会定期让子智能体审核代码变更，尽早发现严重错误。如果你还没有让Claude审核自己的代码，我强烈建议你尝试——它帮我避免了很多麻烦，比如发现关键错误、遗漏的实现、不一致的代码和安全漏洞等。

### PM2进程管理（后端调试的颠覆性工具）
这是我最近才添加的功能，但它让后端问题调试变得容易多了。

#### 遇到的问题
我的项目有7个后端微服务同时运行，问题在于：Claude无法查看服务运行时的日志。当我问“邮件服务出了什么问题？”时，Claude看不到日志——除非我手动复制粘贴到对话中。

#### 过渡解决方案
有一段时间，我让每个服务通过devLog脚本将输出写入带时间戳的日志文件。这种方法虽然能让Claude读取日志，但体验很差：日志不是实时的、服务崩溃后不会自动重启、管理起来也很麻烦。

#### 最终解决方案：PM2
后来我发现了PM2，它彻底改变了后端管理方式。我将所有后端服务配置为通过PM2运行，只需一个命令即可启动：`pnpm pm2:start`

PM2带来的优势如下：
- 每个服务作为受管理的进程运行，拥有独立的日志文件
- Claude能轻松实时读取各个服务的日志
- 服务崩溃后自动重启
- 通过`pm2 logs`命令实现实时监控
- 通过`pm2 monit`命令监控内存/CPU使用情况
- 便捷的服务管理（如`pm2 restart email`重启邮件服务、`pm2 stop all`停止所有服务等）

#### PM2配置示例
```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: 'form-service',
      script: 'npm',
      args: 'start',
      cwd: './form',
      error_file: './form/logs/error.log',
      out_file: './form/logs/out.log',
    },
    // ... 其他6个服务的配置
  ]
};
```

#### 使用PM2前后的调试流程对比
**使用PM2前**：
1. 我：“邮件服务报错了”
2. 我：[手动找到日志并复制]
3. 我：[粘贴到对话中]
4. Claude：“让我分析一下……”

**使用PM2后**：
1. 我：“邮件服务报错了”
2. Claude：[运行] `pm2 logs email --lines 200`
3. Claude：[读取日志后] “我发现问题了——数据库连接超时……”
4. Claude：[运行] `pm2 restart email`
5. Claude：“已重启服务，正在监控是否有错误……”

前后对比非常明显。现在Claude能自主调试问题，我再也不用当“人工日志搬运工”了。

需要注意的一点是：PM2不支持热重载，因此我仍会用`pnpm dev`单独运行前端。但对于不需要频繁热重载的后端服务来说，PM2的表现非常出色。

### 钩子系统（#不留下任何混乱）
我正在处理的项目是多根目录结构，根目录下有8个仓库：1个前端仓库，以及7个后端微服务和工具仓库。根据功能需求，我经常需要在多个仓库间切换并修改代码。

最让我恼火的是：Claude经常忘记在它编辑的仓库中运行构建命令来检查错误，结果留下十几个TypeScript错误却没被发现。几小时后，当我看到Claude像模像样地运行构建脚本时，却看到这样的输出：“有几个TypeScript错误，但它们无关紧要，所以没问题！”

显然，这根本不是“没问题”，Claude。

#### 钩子1：文件编辑跟踪器
首先，我创建了一个post-tool-use钩子，它会在每次“编辑/写入/多文件编辑”操作后运行，记录以下信息：
- 被编辑的文件
- 文件所属的仓库
- 时间戳

最初我设置为每次编辑后立即运行构建，但这种方式效率极低——因为Claude经常会先修改代码导致错误，然后很快又修正。

#### 钩子2：构建检查器
之后我添加了一个Stop钩子，它会在Claude回复完成后运行，具体功能如下：
- 读取编辑日志，确定哪些仓库被修改过
- 在每个受影响的仓库中运行构建脚本
- 检查TypeScript错误
  - 如果错误数<5：将错误展示给Claude
  - 如果错误数≥5：建议启动自动错误解决智能体
- 记录所有操作，便于调试

自从实现这个系统后，Claude再也没有留下过我后续才发现的代码错误——钩子会立即捕捉错误，Claude会在继续工作前修正它们。

#### 钩子3：Prettier格式化器
这个钩子很简单，但效果很好：在Claude回复完成后，会使用对应仓库的.prettierrc配置文件，自动用Prettier格式化所有被编辑的文件。

以前经常出现这样的情况：我手动编辑一个文件时，Prettier一运行就会产生20处修改——因为上周Claude创建这个文件时忘了加尾随逗号。有了这个钩子，这种问题就再也不会发生了。

⚠️ 更新：我不再推荐使用这个钩子

发布本文后，有位读者分享了详细数据：文件修改会触发<system-reminder>通知，而这类通知会消耗大量上下文令牌。在他们的案例中，仅3轮对话，Prettier格式化就因系统通知显示文件差异而消耗了16万个令牌。

尽管影响程度因项目而异（大文件和严格的格式化规则会导致最糟糕的情况），但我还是从自己的系统中移除了这个钩子。其实手动编辑文件时再进行格式化也没什么麻烦，为了这点便利而消耗大量令牌并不值得。

如果你需要自动格式化，建议在Claude对话间隙手动运行Prettier，而不是在对话过程中自动运行。

#### 钩子4：错误处理提醒
这就是我之前提到的“温和提醒型钩子”，功能如下：
- 在Claude回复完成后分析被编辑的文件
- 检测高风险代码模式（try-catch、异步操作、数据库调用、控制器代码等）
- 如果发现高风险代码，显示温和的提醒
- 让Claude自行评估是否需要添加错误处理
- 不阻碍操作、无额外摩擦，仅起到“提醒注意”的作用

提醒输出示例：
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 错误处理自检
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️  检测到后端代码变更
   共编辑了2个文件

   ❓ catch块中是否添加了Sentry.captureException()？
   ❓ Prisma操作是否包裹了错误处理代码？

   💡 后端最佳实践：
      - 所有错误都应捕获并发送到Sentry
      - 控制器应继承BaseController
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

#### 完整的钩子流程
现在，每次Claude回复后都会执行以下流程：
1. Claude完成回复
   ↓
2. 钩子1：Prettier格式化器运行 → 所有被编辑文件自动格式化
   ↓
3. 钩子2：构建检查器运行 → 立即捕获TypeScript错误
   ↓
4. 钩子3：错误提醒运行 → 温和提醒进行错误处理自检
   ↓
5. 若发现错误 → Claude看到错误并修正
   ↓
6. 若错误过多 → 建议启动自动错误解决智能体
   ↓
7. 最终结果：获得整洁、格式化、无错误的代码

此外，UserPromptSubmit钩子会确保Claude在开始工作前就加载相关技能——真正实现“不留下任何混乱”，体验非常好。

### 附加到技能的脚本
我从GitHub上Anthropic的官方技能示例中，学到了一个非常实用的模式：将实用脚本附加到技能中。

例如，我的backend-dev-guidelines技能中有一部分关于“已认证路由测试”的内容——我没有只解释认证原理，而是在技能中引用了一个实际可用的脚本：

#### 已认证路由测试方法
使用提供的test-auth-route.js脚本：
```bash
node scripts/test-auth-route.js http://localhost:3002/api/endpoint
```

该脚本会自动处理所有复杂的认证步骤：
1. 从Keycloak获取刷新令牌
2. 用JWT密钥对令牌进行签名
3. 创建Cookie头
4. 发起已认证请求

这样，当Claude需要测试路由时，它确切知道该使用哪个脚本以及如何使用——再也不用“创建测试脚本”，避免了重复造轮子。

我计划进一步扩展这种模式：将更多实用脚本附加到相关技能中，让Claude拥有“即用型工具”，而不是每次都从头生成脚本。

## 其他工具与技巧
### Mac上的SuperWhisper
当我打字累了的时候，会用它进行语音转文字来编写提示词。它的识别效果出奇地好，而且Claude也能很好地理解我略显杂乱的语音转文字内容。

### Memory MCP
随着技能系统承担了大部分“记忆代码模式”的工作，我对这个工具的使用越来越少。但它在跟踪项目特定决策和架构选择方面仍然很有用——这些内容不适合放在技能中。

### BetterTouchTool（BTT）
这个工具的主要用途包括：
- 从Cursor中复制相对URL（用于分享代码引用）：我会打开VSCode以便更快找到所需文件，双击Caps Lock键后，BTT会自动输入复制相对URL的快捷键、在剪贴板内容前添加“@”符号、聚焦终端并粘贴文件路径——整个过程一键完成。
- 双击热键快速切换应用（按两次CMD键打开Claude Code，按两次OPT键打开浏览器）
- 为常用操作设置自定义手势

说实话，单是“不用在应用间笨拙切换”这一点，就值得购买BTT了——它节省的时间非常可观。

### 万物皆可脚本
对于任何繁琐重复的任务，几乎都能找到对应的脚本解决方案。我目前使用的脚本包括：
- 命令行工具生成模拟测试数据：在使用Claude之前，生成模拟数据非常麻烦——我需要填写一个包含120个问题的表单，才能生成一个测试提交数据。
- 认证测试脚本（获取令牌、测试路由）
- 数据库重置与数据填充脚本
- 迁移前的 schema 差异检查脚本
- 开发数据库自动备份与恢复脚本

实用提示：当Claude帮你编写了一个有用的脚本后，立即将其文档记录在CLAUDE.md中，或附加到相关技能中——未来的你会感谢现在的你。

## 文档（依然重要，但已升级）
我认为，除了规划之外，文档的重要性几乎不亚于其他任何环节。除了为每个任务或功能创建的开发文档外，我还会随时记录所有内容——从系统架构、数据流图到实际的开发文档和API文档，不一而足。

但现在有一个重要变化：文档不再是“替代技能”，而是“与技能协同工作”。

两者的分工如下：
- 技能包含：可复用模式、最佳实践、操作指南
- 文档包含：系统架构、数据流、API参考、集成点

举几个例子：
- “如何创建控制器”→ 参考backend-dev-guidelines技能
- “我们的工作流引擎如何运作”→ 参考架构文档
- “如何编写React组件”→ 参考frontend-dev-guidelines技能
- “通知如何在系统中流转”→ 参考数据流图 + notification技能

我现在仍有大量文档（超过850个markdown文件），但它们现在专注于“项目特定架构”，而不是重复那些更适合放在技能中的通用最佳实践。

你不一定需要做到这么极致，但我强烈建议搭建“多层级文档”：先为特定服务编写宏观的架构概述文档，然后在其中包含指向“各架构部分详细文档”的链接。这会大大提升Claude轻松导航代码库的能力。

## 提示词编写技巧
编写提示词时，你应该尽可能明确地说明自己想要的结果。再强调一次：你不会让建筑工人在不讨论设计方案的情况下就开始扩建浴室，对吧？

“你说得对！在浴室里铺长绒地毯可能确实不是个好主意。”

有时候你可能不清楚具体需求，这也没关系。如果你有疑问，可以让Claude先调研，然后返回多个潜在解决方案；你甚至可以使用专门的子智能体，或其他AI聊天界面来进行调研——方法有很多。相信我，这样做会带来丰厚回报：你能更好地判断Claude生成的计划是好是坏，是否需要调整。否则，你就像在“盲目编码”，最终可能连“需要包含哪些上下文”都不知道，因为你根本不清楚要修复的问题涉及哪些文件。

如果你想要诚实、无偏见的反馈，编写提示词时请避免“引导性提问”。如果你对Claude的某个操作不确定，不要问“这是好是坏？”，而是用中立的方式提问。Claude往往会说你想听的话，引导性问题会让结果产生偏差。更好的做法是描述具体情况，然后询问它的想法或其他方案——这样你才能得到更全面的答案。

## 智能体、钩子与斜杠命令（三位一体）
### 智能体（Agents）
我搭建了一支小型的“专业智能体团队”，按功能分为以下几类：

**质量控制类**
- code-architecture-reviewer：审核代码是否符合最佳实践
- build-error-resolver：系统性修复TypeScript错误
- refactor-planner：制定全面的重构计划

**测试与调试类**
- auth-route-tester：测试带认证的后端路由
- auth-route-debugger：调试401/403错误和路由问题
- frontend-error-fixer：诊断并修复前端错误

**规划与策略类**
- strategic-plan-architect：制定详细的实现计划
- plan-reviewer：在实现前审核计划
- documentation-architect：创建/更新文档

**特定功能类**
- frontend-ux-designer：修复样式和用户体验问题
- web-research-specialist：调研问题及其他各类网络信息
- reactour-walkthrough-designer：创建UI引导流程

使用智能体的关键在于：给它们“非常明确的角色”和“清晰的输出要求”。我曾吃过亏——之前创建的智能体有时会“擅自行动”，最后只回复一句“我修好了！”，却不说明具体修复了什么。

### 钩子（Hooks，前文已详细介绍）
钩子系统是连接所有环节的核心。没有钩子会出现很多问题：
- 技能文档被闲置
- 错误被遗漏
- 代码格式不一致
- 没有自动质量检查

而有了钩子后，情况完全不同：
- 技能自动激活
- 零错误遗漏
- 代码自动格式化
- 内置质量意识

### 斜杠命令（Slash Commands）
我创建了不少自定义斜杠命令，以下是我最常用的几个，按功能分类：

**规划与文档类**
- /dev-docs：创建全面的战略计划
- /dev-docs-update：压缩对话前更新开发文档
- /create-dev-docs：将已通过的计划转换为开发文档文件

**质量与审核类**
- /code-review：进行架构层面的代码审核
- /build-and-fix：运行构建并修复所有错误

**测试类**
- /route-research-for-testing：找到受影响的路由并启动测试
- /test-route：测试特定的已认证路由

斜杠命令的优势在于：它们能扩展为完整的提示词，因此你可以在一个简单命令中包含大量上下文和指令——这比每次都输入相同的指令要高效得多。

## 总结
经过6个月的高强度使用，我总结出以下经验：

### 核心必备要素
1. 全面规划：使用计划模式或strategic-plan-architect智能体
2. 技能+钩子：自动激活是确保技能可靠发挥作用的唯一方式
3. 开发文档系统：防止Claude偏离目标
4. 代码审核：让Claude审核自己的代码
5. 后端使用PM2：让调试变得轻松可行

