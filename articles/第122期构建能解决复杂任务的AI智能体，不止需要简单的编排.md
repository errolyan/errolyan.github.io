# 第122期:构建能解决复杂任务的AI智能体，不止需要简单的编排


AI智能体正在改变应用程序与用户交互及自动化任务的方式。与传统程序不同，这些智能体借助生成式AI解读数据、制定决策，并在极少人工干预的情况下完成任务。

通过利用大型语言模型（LLM），智能体能够简化复杂的工作流程，因此非常适合自动化费用管理、客户服务、文档分析等业务流程。开发AI智能体可使用多种不同的工具和平台。


![](https://fastly.jsdelivr.net/gh/bucketio/img18@main/2025/10/01/1759301684839-8e08a104-82a5-45d9-b13d-ec34805ce8d3.png)


在《如何使用AI Foundry构建Azure AI智能体》一文中，我们探讨了如何以及为何使用Azure AI智能体SDK构建智能体。该文章为我们全面介绍了Azure AI Foundry智能体服务——这是一项全托管服务，用于构建、部署和扩展高质量、可扩展的AI智能体，无需担心计算或存储问题。

本文将更进一步：介绍Semantic Kernel（语义内核）——微软的开源SDK，它通过额外的灵活性、插件和多智能体编排功能，扩展了Foundry智能体的能力。


## 什么是Semantic Kernel？
Semantic Kernel是一款开源SDK，能让开发人员轻松将最新的AI模型集成到自己的应用程序中。该SDK的一部分包含Semantic Kernel智能体框架，开发人员可借助该框架快速创建功能型智能体，这些智能体能够使用自然语言处理完成任务。

Semantic Kernel提供了可单独使用或组合使用的不同组件，具体如下：
- **AI服务连接器**：通过统一接口，将代码与来自不同提供商的AI服务相连。支持的服务包括聊天补全、文本生成等。
- **内存连接器**：通过统一接口，展示来自其他提供商的向量存储。
- **函数与插件**：用于存储在内核中注册的函数的容器。函数注册后，可由AI调用或通过提示模板调用。
- **提示模板**：将指令、用户输入和函数输出组合成可复用的格式。提示模板能让AI模型动态执行预定义步骤。
- **过滤器**：允许在调用函数或提示之前和之后执行自定义操作。注册后，函数过滤器可作为外层，提示过滤器可作为内层。


## 为何选择Semantic Kernel？
Azure AI Foundry智能体服务已提供以下功能：
- 安全且可扩展的部署环境
- 访问预构建工具的权限
- 简化的资源管理

但如果您尝试过构建更复杂的工作流程，就会发现一些问题：
- 可能需要超出内置工具范围的自定义逻辑
- 可能希望组合不同类型的智能体（基于聊天的智能体、OpenAI助手、Azure原生智能体等）
- 可能希望尝试多智能体系统，让多个智能体协同工作

这正是Semantic Kernel（SK）相比Azure AI智能体（SDK）具备更高灵活性和复杂性的原因。因此，Semantic Kernel这款SDK能轻松实现以下操作：
- 构建不同类型的智能体（如ChatCompletionAgent、OpenAIAssistantAgent、AzureAIAgent）
- 定义可将智能体连接到API或内部系统的插件和函数
- 添加内存和规划功能，让智能体能够利用历史信息并分解复杂任务
- 与Azure AI Foundry无缝集成，以便将智能体扩展到生产环境


## Semantic Kernel智能体框架
SK智能体框架支持多种智能体类型，包括：
- **ChatCompletionAgent**：基于LLM构建，适用于对话类任务。
- **OpenAIAssistantAgent**：直接与OpenAI助手集成。
- **AzureAIAgent**：通过Semantic Kernel功能扩展Azure AI Foundry智能体。

其中，**AzureAIAgent**是本文的重点。它允许您在SK中编写智能体逻辑，同时仍在Foundry智能体服务上部署和扩展该智能体。这意味着从原型到生产环境的迁移过程中，您无需重写代码。

AzureAIAgent类提供了一种无缝的方式，可通过Foundry智能体服务构建和交互AI智能体。它通过在Semantic Kernel智能体框架内提供更结构化、更直观的接口，简化了AI智能体的管理复杂性。其主要优势包括：
- **简化智能体创建**：AzureAIAgent类允许开发人员通过最少的配置定义AI智能体，无需管理底层基础设施，即可利用Foundry智能体服务的能力。
- **自动工具调用**：该智能体可自动调用和执行工具，与Azure AI搜索、必应（Bing）、Azure Functions等服务无缝集成。
- **线程与对话管理**：提供内置机制管理对话状态，确保多智能体交互顺畅进行。
- **安全的企业集成**：支持无密钥身份验证和可自定义的存储选项，实现安全、合规的AI智能体开发。

通过使用AzureAIAgent类，开发人员既能充分利用Foundry智能体服务的优势，又能借助Semantic Kernel SDK提供的功能，构建可在企业应用中高效扩展的强大AI驱动工作流程。


## 智能体工具：为Azure AI智能体添加插件
在Semantic Kernel中，插件能让AI智能体利用现有API执行自身无法独立完成的任务。插件通过函数调用实现功能，AI可请求并使用特定函数。Semantic Kernel会将请求路由到代码库中相应的函数，并将结果返回给LLM，以便LLM生成最终响应。

要通过函数调用实现自动编排，插件还需提供描述其行为的详细信息。函数的输入、输出和副作用应以AI可理解的方式描述，否则AI无法正确调用该函数。

### 如何在AzureAIAgent中使用插件？
#### 1. 定义插件
您可以通过定义一个类，并使用`kernel_function`装饰器（decorator）对其方法进行注解，从而创建插件。该装饰器会告知Semantic Kernel，此函数可由AI调用或在提示中引用。`kernel_function`装饰器还支持`description`属性，帮助AI理解如何使用该函数。

#### 2. 向智能体添加插件
定义插件后，您可以创建该插件的实例，并将其添加到AzureAIAgent的插件集合中，从而将插件集成到智能体中。

#### 3. 调用插件的函数
您可以通过在智能体的消息线程中发送提示，调用插件的函数。例如，如果您有一个名为`get_tasks`的插件函数，向智能体发送的提示可以是“我有哪些任务？”。

### 示例：费用报告自动化
假设您要构建一个AI智能体，为员工自动格式化费用报告并通过电子邮件发送，具体流程如下：
1. 员工上传原始费用数据
2. 智能体提取并格式化信息
3. 智能体将最终报告通过电子邮件发送给指定接收人

借助Semantic Kernel，您只需几个步骤即可构建该智能体：
```python
import semantic_kernel as sk
from semantic_kernel.agents.azure_ai_agent import AzureAIAgent

# 初始化内核
kernel = sk.Kernel()

# 创建Azure AI智能体
agent = AzureAIAgent(
    kernel=kernel,
    project_name="ExpenseAutomation",  # 项目名称：费用自动化
    deployment_name="gpt-4o-mini"     # 部署名称：gpt-4o-mini
)

# 定义插件函数
@kernel.function
async def format_expense_report(data: str) -> str:
    return f"Formatted Report:\n{data}"  # 返回格式化后的报告

# 向智能体添加插件
agent.add_function(format_expense_report)

# 运行智能体
result = await agent.complete("Process this expense report and send by email.")  # 处理此费用报告并通过电子邮件发送
print(result)  # 打印结果
```

此代码片段展示了Semantic Kernel的插件和函数如何帮助智能体连接业务工作流程。在实际部署中，该插件可调用电子邮件API或企业资源计划（ERP）系统，以端到端完成任务。


## 超越单一智能体：多智能体协同
AI智能体结合多种技术，能够借助生成式AI完成任务。但在某些情况下，所需完成的任务可能过于复杂，单一智能体难以实现。对于这类场景，可考虑采用多智能体方案——让多个智能体在同一对话中协同工作。

### 为何以及何时使用多个智能体？
单一智能体系统的范围通常较为有限，受限于一组指令或单个模型提示。那么，用单个提示完成涉及多个阶段的复杂任务会有哪些局限性呢？有时，任务或工作流程的复杂性会导致智能体的性能稳定性参差不齐，因为将所有内容整合到单个上下文提示中，很难确保每次都能正确处理所有内容。

多智能体编排通过以下方式解决了这一局限性：
- 为每个智能体分配不同的技能、职责或视角
- 结合多个智能体的输出，提高决策的准确性
- 协调工作流程中的步骤，使每个智能体的工作都能基于前一个智能体的成果展开
- 根据上下文或规则，在智能体之间动态转移控制权

这种方案为更灵活、高效且可扩展的解决方案提供了可能，尤其适用于需要协同、专业化分工或冗余设计的实际应用场景。

这类智能体间的协同是Semantic Kernel的突出功能之一，称为“GroupChat（群聊）”。例如，一个智能体负责格式化费用报告，另一个负责检查合规性规则，第三个负责审批并发送报告。GroupChat会协调它们的交互，确保高效协作。

这正是Semantic Kernel对AI Foundry的重要扩展：它不仅能协调单个智能体，还能协调一整个智能体团队，让它们分别处理业务工作流程的不同部分。智能体框架中仍可使用支持Semantic Kernel的各项功能，包括：
- **内核（Kernel）**：Semantic Kernel的核心组件，作为执行引擎，负责管理AI交互、函数编排和内存。
- **工具与插件**：插件与Semantic Kernel的现有功能保持一致，使智能体能够通过函数调用动态与外部服务交互或执行复杂任务。在智能体框架中，工具可为智能体提供额外功能（如文件搜索、代码解释器），类似于Azure AI Foundry智能体服务中的工具使用方式。智能体通过工具和插件执行特定任务。
- **历史记录（History）**：智能体可在多次交互中保留聊天记录，从而跟踪之前的交互内容并调整响应。所有智能体都能访问对话历史记录，既可以查看完整记录，也可以查看特定智能体的聊天记录。


## 编排模式
Semantic Kernel在SDK中直接提供了多种编排模式，每种模式都采用不同的方法协调智能体。这些模式设计为与技术无关，因此您可以根据自身领域调整它们，并将其集成到现有系统中。

1. **并发编排（Concurrent Orchestration）**：将同一任务同时分配给多个智能体，独立收集它们的结果。适用于并行分析、独立子任务处理或集成决策制定场景。


![](https://fastly.jsdelivr.net/gh/bucketio/img9@main/2025/10/01/1759301730213-8545b4d6-6d31-430a-88b6-69eaec9dcb37.png)


当您需要通过不同方法或思路解决同一问题时，并发编排模式非常有用。无需让智能体依次工作，而是让它们同时处理任务，这样既能加快流程，又能从多个角度解决问题。

2. **顺序编排（Sequential Orchestration）**：按固定顺序将一个智能体的输出传递给下一个智能体。非常适合分步工作流程、管道处理和渐进式优化场景。


![](https://fastly.jsdelivr.net/gh/bucketio/img9@main/2025/10/01/1759301746834-714f1d44-ffc3-44d4-9927-e5be2fe470eb.png)


顺序编排将智能体组织成一个管道，每个智能体依次处理任务。这种模式适用于步骤间存在依赖关系的顺序任务，例如文档审核、数据转换管道或多阶段推理任务。

3. **移交编排（Handoff Orchestration）**：根据上下文或规则，在智能体之间动态转移控制权。非常适合问题升级、备用方案启用和专家路由场景（同一时间只有一个智能体工作）。


![](https://fastly.jsdelivr.net/gh/bucketio/img5@main/2025/10/01/1759301768253-719dad1d-8d33-4277-92b2-d2f7e97e3370.png)


移交编排允许AI智能体根据任务上下文或用户请求将控制权转移给其他智能体。每个智能体都可以将对话“移交”给具备相应专业知识的智能体，确保任务的每个部分都由最适合的智能体处理。这种模式适用于客户支持、专家系统或任何需要动态委派任务的场景，尤其适合预先无法确定最佳智能体，或任务需求在处理过程中逐渐清晰的情况。

4. **群聊编排（Group Chat Orchestration）**：协调多个智能体（可选包含人类）之间的共享对话，由聊天管理器控制发言顺序（即充当主持人），决定下一个发言的智能体以及何时需要人类输入。最适合头脑风暴、协同问题解决和达成共识的场景。


![](https://fastly.jsdelivr.net/gh/bucketio/img18@main/2025/10/01/1759301782658-729501fd-dc92-4e70-b6a1-3051f4b04f7f.png)


5. **磁石编排（Magentic Orchestration）**：一种由管理器驱动的模式，通过专业智能体团队进行规划、委派和调整。适用于复杂、开放式问题（解决方案路径会不断演变）的场景。


![](https://fastly.jsdelivr.net/gh/bucketio/img0@main/2025/10/01/1759301794234-4d03a8b2-3e65-4ea4-ad17-c417aefbdfe4.png)



## 编排管理
编排的一个重要方面是如何管理智能体的生命周期。**运行时（Runtime）** 是核心组件，能够确保编排可靠、可扩展地执行、通信和与智能体交互。

运行时作为编排的执行引擎，为智能体提供了发送和接收消息、运行任务及管理资源的渠道，具体功能包括：
- **消息路由**：在智能体和特定于编排的参与者之间传递消息，根据编排设计采用直接消息传递或发布-订阅（pub-sub）式消息传递。
- **参与者生命周期管理**：创建、注册和管理所有参与的智能体及编排参与者，确保每个组件独立、安全地运行。
- **执行上下文**：允许多个编排同时运行，每个编排都有自己的状态和资源，互不干扰。


## 顺序编排的代码示例
```python
import asyncio
from semantic_kernel.agents import Agent, ChatCompletionAgent, SequentialOrchestration
from semantic_kernel.agents.runtime import InProcessRuntime
from semantic_kernel.connectors.ai.open_ai import AzureChatCompletion
from semantic_kernel.contents import ChatMessageContent

def get_agents() -> list[Agent]:
    # 总结器智能体指令
    summarizer_instructions="""
    将客户反馈总结为一个简短的句子，保持中立和简洁。
    示例输出：
    应用在照片上传时崩溃。
    用户称赞深色模式功能。
    """
    # 分类器智能体指令
    classifier_instructions="""
    将反馈分类为以下类别之一：正面（Positive）、负面（Negative）、功能请求（Feature request）。
    """
    # 行动建议智能体指令
    action_instructions="""
    根据总结和分类，用一个简短的句子提出下一步行动建议。
    示例输出：
    作为高优先级漏洞升级给移动团队。
    将正面反馈记录下来，分享给设计和市场团队。
    将增强功能请求记录到产品待办事项中。
    """
    
    # 创建总结器智能体
    summarizer_agent = ChatCompletionAgent(
        name="SummarizerAgent",  # 智能体名称：总结器智能体
        instructions=summarizer_instructions,
        service=AzureChatCompletion(),
    )
    
    # 创建分类器智能体
    classifier_agent = ChatCompletionAgent(
        name="ClassifierAgent",  # 智能体名称：分类器智能体
        instructions=classifier_instructions,
        service=AzureChatCompletion(),
    )
    
    # 创建行动建议智能体
    action_agent = ChatCompletionAgent(
        name="ActionAgent",  # 智能体名称：行动建议智能体
        instructions=action_instructions,
        service=AzureChatCompletion(),
    )
    
    return [summarizer_agent, classifier_agent, action_agent]

# 智能体响应回调函数
def agent_response_callback(message: ChatMessageContent) -> None:
    print(f"# {message.name}\n{message.content}")

async def main():
    # 任务内容（客户反馈）
    task="""
    今天我尝试更新个人资料图片好几次，但应用程序总是在中途卡住。
    我不得不重启了三次，最后图片还是没能上传成功。
    这太令人沮丧了，也让这个应用显得很不可靠。
    """
    
    # 创建顺序编排实例
    sequential_orchestration = SequentialOrchestration(
        members=get_agents(),  # 参与编排的智能体
        agent_response_callback=agent_response_callback,  # 智能体响应回调
    )
    
    # 初始化进程内运行时
    runtime = InProcessRuntime()
    runtime.start()  # 启动运行时
    
    # 调用顺序编排
    orchestration_result = await sequential_orchestration.invoke(
        task=task,  # 任务内容
        runtime=runtime,  # 运行时
    )
    
    # 获取编排结果（超时时间20秒）
    value = await orchestration_result.get(timeout=20)
    
    # 打印输入任务和最终结果
    print(f"\n****** 任务输入 ******{task}")
    print(f"***** 最终结果 *****\n{value}")
    
    # 当运行时空闲时停止
    await runtime.stop_when_idle()

# 程序入口
if __name__ == "__main__":
    asyncio.run(main())
```


## 核心要点
学习完本模块后，您应能够：
- 使用Semantic Kernel连接Azure AI Foundry项目。
- 借助Semantic Kernel SDK创建Foundry智能体服务智能体。
- 通过插件函数扩展智能体功能，以适配实际业务任务。
- 理解何时需从单一智能体SDK使用场景，过渡到Semantic Kernel编排模式。


## 结语
Azure AI智能体SDK为您提供了在云端构建和部署智能体的入门基础，但如果您希望增加智能体的灵活性、可定制性和可扩展性，Semantic Kernel便是自然而然的下一步选择。它填补了开发工作流与企业级部署之间的空白。

无论您是要实现费用报告自动化，还是构建用于客户服务的多智能体协同系统，Semantic Kernel与AI Foundry的组合都能为您提供所需工具，助力您构建、部署并扩展智能体——这些智能体不仅能被动响应任务，更能主动协作以应对复杂挑战。


## 参考资料
- Developing AI Agents with Semantic Kernel（使用Semantic Kernel开发AI智能体）
- Semantic Kernel GitHub仓库
- How to build AI Agents using Azure AI Agents SDK and AI Foundry（如何使用Azure AI智能体SDK和AI Foundry构建AI智能体）
- Azure AI Foundry官方文档
- Tools for Azure AI Agents（Azure AI智能体工具集）